#-*- mode: org -*-
#+TITLE=Main config file
#+STARTUP:overview

#+begin_quote
(What the world needs (I think) is not
      (a Lisp (with fewer parentheses))
      but (an English (with more.)))
-- Brian Hayes, http://tinyurl.com/3y9l2kf
#+end_quote

#+begin_quote
 Emacs is a flexible platform for developing end-user applications
   –unfortunately it is generally perceived as merely a text editor.
Some people use it specifically for one or two applications.
-- https://alhassy.github.io/init/
#+end_quote

#+begin_quote
I’m rarely happier than when spending an entire day programming my computer
  to perform automatically a task that would otherwise take me a
  good ten seconds to do by hand.
-- Douglas Adams
#+end_quote

#+begin_quote
“You don’t have to like Emacs to like it.”
-- https://www.gnu.org/software/emacs/manual/html_node/eintr/Emacs-Initialization.html
#+end_quote

* Change a few defaults
** Set some vars

#+BEGIN_SRC elisp
(setq
 ;; Personal data
 user-full-name "Laura Brustenga i Moncusí"
 user-mail-address "laurea987@gmail.com"

 ;; Scratch buffer
 initial-scratch-message ";; ╔═╗┌─┐┬─┐┌─┐┌┬┐┌─┐┬ ┬\n;; ╚═╗│  ├┬┘├─┤ │ │  ├─┤\n;; ╚═╝└─┘┴└─┴ ┴ ┴ └─┘┴ ┴\n"
 ;; doom-scratch-initial-major-mode 'lisp-interaction-mode

 ;; European agenda.
 ;; european-calendar-style t
 calendar-week-start-day 1

 ;; Local Variables Set save all local variable and do not query.
 ;; enable-local-variables :all

 ;; Buffer line numbers
 ;; Line numbers are pretty slow all around. The performance boost of
 ;; disabling them outweighs the utility of always keeping them on.
 display-line-numbers-type nil
 ;; (global-display-line-numbers-mode -1)

 ;; Killing Emacs with no questions
 confirm-kill-emacs nil

 ;; Clipboard save the current (system) clipboard before replacing it with the Emacs' text.
 save-interprogram-paste-before-kill t
 ;; kill-ring-max 50

 ;; Real buffers
 doom-unreal-buffer-functions '(minibufferp)
;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
 doom-font (font-spec :family "IBM Plex Mono" :size 16 :weight 'light)

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
doom-theme 'doom-one
;; doom-theme 'doom-fairy-floss

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
org-directory "~/Dropbox/Org"

 ;; Visual fill mode
 ;; It is like visual line mode but breaks the lines at =fill-column=.
 ;; For visual-fill-mode see https://github.com/hlissner/doom-emacs/pull/1906/files
 +word-wrap-extra-indent 'single
 )
#+END_SRC

** Dashboard menu
#+begin_src elisp
(setq +doom-dashboard-menu-sections
      '(
        ;; ("Load workspace"
        ;;  :icon
        ;;  (all-the-icons-octicon "rocket" :face 'doom-dashboard-menu-title)
        ;;  :action +workspace/load)
        ;; ("Open file in Dropbox"
        ;;  :icon
        ;;  (all-the-icons-octicon "rocket" :face 'doom-dashboard-menu-title)
        ;;  :action +workspace/load)
        ("Open my org"
         :icon
         (all-the-icons-fileicon "org" :face 'doom-dashboard-menu-title)
         :when (file-exists-p (expand-file-name "~/Dropbox/Org/my.org"))
         :action brust-open-my-org)
        ;; :action (lambda nil (open-file (expand-file-name "~/Dropbox/Org/my.org"))))
        ("Email"
         :icon (all-the-icons-octicon "mail" :face 'font-lock-keyword-face)
         :action mu4e)
        ;; ("Open register" :icon
        ;;  (all-the-icons-octicon "bookmark" :face 'doom-dashboard-menu-title)
        ;;  :action jump-to-register)
        ;; ("Jump to bookmark"
        ;;  :icon (all-the-icons-octicon "bookmark" :face 'doom-dashboard-menu-title)
        ;;  :action bookmark-jump)
        ("Open org-agenda"
         :icon
         (all-the-icons-octicon "calendar" :face 'doom-dashboard-menu-title)
         :when (fboundp 'org-agenda)
         :action org-agenda)
        ;; ("Reload last session"
        ;;  :icon
        ;;  (all-the-icons-octicon "history" :face 'doom-dashboard-menu-title)
        ;;  :when (file-exists-p (expand-file-name persp-auto-save-fname persp-save-dir))
        ;;  :face
        ;;  (:inherit
        ;;   (doom-dashboard-menu-title bold))
        ;;  :action doom/quickload-session)
        ("Open private configuration"
         :icon (all-the-icons-octicon "tools" :face 'doom-dashboard-menu-title)
         :when (file-directory-p doom-private-dir)
         :action doom/open-private-config)
        ;; ("Notes"
        ;;  :icon (all-the-icons-octicon "light-bulb" :face 'font-lock-keyword-face)
        ;;  :action ragone-deft-or-close)
        ;; ("Passwords"
        ;;  :icon (all-the-icons-octicon "lock" :face 'font-lock-keyword-face)
        ;;  :action pass)
        ;; ("IRC"
        ;;  :icon (all-the-icons-faicon "comments" :face 'font-lock-keyword-face)
        ;;  :action =irc)))
        ))
#+end_src
** Lookup online
#+begin_src elisp
(setq +lookup-provider-url-alist
      '(;; ("Doom Emacs issues" "https://github.com/hlissner/doom-emacs/issues?q=is%%3Aissue+%s")
        ("Google"            +lookup--online-backend-google "https://google.com/search?q=%s")
        ("Wikipedia"         "https://wikipedia.org/search-redirect.php?language=en&go=Go&search=%s")
        ("Thesaurus"         "https://www.thesaurus.com/browse/%s")
        ("Singular Manual"   "https://www.google.com/search?q=site:www.singular.uni-kl.de+%s")
        ;; ("Project Gutenberg" "http://www.gutenberg.org/ebooks/search/?query=%s")
        ;; ("DuckDuckGo"        +lookup--online-backend-duckduckgo "https://duckduckgo.com/?q=%s")
        ("DevDocs.io"        "https://devdocs.io/#q=%s")
        ("StackOverflow"     "https://stackoverflow.com/search?q=%s")
        ("Github"            "https://github.com/search?ref=simplesearch&q=%s")
        ("Youtube"           "https://youtube.com/results?aq=f&oq=&search_query=%s")
        ("Wolfram alpha"     "https://wolframalpha.com/input/?i=%s")
        ("Google images"     "https://www.google.com/images?q=%s")
        ("Google maps"       "https://maps.google.com/maps?q=%s")
        ))
#+end_src

** Delete selection on type.
#+BEGIN_SRC elisp
(add-hook! 'emacs-startup-hook (delete-selection-mode 1))
;; (setq delete-selection-save-to-register 'kill-ring)
#+END_SRC
** Faces
#+begin_src elisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(highlight ((t (:background "#51afef" :foreground "black" :weight bold)))))
#+end_src
** Enabling

#+begin_src elisp
(put 'erase-buffer 'disabled nil)
#+end_src

* Mode Line
** Do not show
#+begin_src elisp
(setq column-number-mode nil
      size-indication-mode nil
      ;; doom-modeline-buffer-encoding nil
      line-number-mode nil)
#+end_src

** Show size: Total number of lines
*** New face (small and grey)
#+begin_src elisp
(make-face 'mode-line-top-line-number)

(set-face-attribute
 'mode-line-top-line-number nil
 :inherit 'mode-line
 :foreground "gray60" :height 0.7)
#+end_src

*** Mode line string
#+begin_src elisp
(defsubst brust-line-number-mode--string nil
  "Show current line/buffer total number of lines."
  (concat (doom-modeline-spc)
          ;; (:propertize "\[" face mode-line-bars-face)
          (propertize "%l"
                      'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                      'help-echo "Buffer size mouse-1: Display Line and Column Mode Menu"
                      'mouse-face 'mode-line-highlight
                      'local-map mode-line-column-line-number-mode-map)
          (propertize (if brust-line-number-mode-show-total
                          (concat "/" (brust--number-of-lines-current-buffer))
                        "")
                      'face 'mode-line-top-line-number
                      'help-echo "Buffer size mouse-1: Display Line and Column Mode Menu"
                      ;; 'mouse-face 'mode-line-highlight
                      'local-map mode-line-column-line-number-mode-map)
          (doom-modeline-spc)))
#+end_src

*** Minor mode
#+begin_src elisp
(defgroup brust-line-number-mode nil "Show current and total number line.")

(defcustom brust-line-number-mode-show-total t
  "Show buffer's total number of lines in mode-line"
  :group 'brust-line-number-mode
  :type 'bool)

(define-minor-mode brust-line-number-mode
  "Toggle show current and total number line in the mode line (Brust Line Number mode).
With a prefix argument ARG, enable it if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Line numbers do not appear for very large buffers and buffers
with very long lines; see variables `line-number-display-limit'
and `line-number-display-limit-width'."
  :init-value t :global t :group 'brust-line-number-mode
  (or global-mode-string (setq global-mode-string '("")))
  (setq global-mode-string
        (delete '(:eval (brust-line-number-mode--string)) global-mode-string))
  (if brust-line-number-mode
      (unless (member '(:eval (brust-line-number-mode--string)) global-mode-string)
        (setq global-mode-string
              (append global-mode-string '((:eval (brust-line-number-mode--string))))))))

;; (add-hook! 'emacs-startup-hook
;;   (setq global-mode-string '("" (:eval (brust-line-number-mode--string)) display-time-string)))
#+end_src

*** Activate
#+begin_src elisp
(add-hook! 'emacs-startup-hook (brust-line-number-mode +1))
#+end_src

** Display time
#+begin_src elisp
(defun brust-kill-date nil
  (interactive)
  (kill-new (format-time-string "%e/%m/%Y" (current-time))))

(defun brust-message-date nil
  (interactive)
  (message (format-time-string "w%Wd%j %A, %e %B %Y, (%e/%m/%Y - %R %Z) -- %s" (current-time))))

(defvar mode-line-display-time-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mode-line mouse-1] #'brust-message-date)
    (define-key map [mode-line mouse-3] #'brust-kill-date)
    map) "\
Keymap to show or kill current date.")

;; Time format
(add-hook! 'emacs-startup-hook
  (customize-set-variable 'display-time-string-forms
                          '((propertize (concat " " 12-hours ":" minutes am-pm " ")
                                        'face 'mode-line
                                        'help-echo "Current date: mouse 1 show, mouse 3 kill"
                                        'local-map mode-line-display-time-mode-map)))
  (setq display-time-default-load-average nil)
  (display-time-mode +1))
#+end_src

* Doom modules
** Biblio
#+begin_src elisp :tangle no
;; In org-mode-map
;; :desc "Biblio" "C" #'ivy-bibtex-with-local-bibliography
;; In LaTeX-mode-map
;; "c" #'ivy-bibtex-with-local-bibliography
#+end_src
*** Citar

- [ ] Learn to use local bibliography

#+begin_src elisp
(after! citar
  (setq citar-symbols
        `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
          (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
          (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))
        citar-symbol-separator "  "
        citar-bibliography '("~/Dropbox/bibliography/my.bib")
        citar-library-paths '("~/Dropbox/bibliography/pdf/"
                              "~/Dropbox/bibliography/")
        citar-notes-paths '("~/Dropbox/bibliography/notes.org"))
  )
#+end_src

*** BibTeX

Editing =.bib= files.

#+begin_src elisp
(after! (latex bibtex)
  (add-to-list 'auto-mode-alist '("\\.bib\\'"  . bibtex-mode))
  (setq bibtex-maintain-sorted-entries t ;; to sort bibtex entries with C-c C-c
        bibtex-comma-after-last-field t ;; coma is inserted after last field
        bibtex-entry-format
        (append '(whitespace
                  realign
                  unify-case
                  last-comma
                  sort-fields)
                (delq! 'required-fields bibtex-entry-format))))
#+end_src
*** COMMENT Get bib entries from the web
**** Bibretrive
Getting bib entries from MathSciNet or arxiv
#+BEGIN_SRC elisp :tangle no
;; See https://github.com/pzorin/bibretrieve
(use-package! bibretrieve
  :commands bibretrieve
  :init
  (setq bibretrieve-prompt-for-bibtex-file nil ;; use defaul bib file
        bibretrieve-backends '(("msn" . 10) ("arxiv" . 5))))
#+END_SRC

**** Biblio

- [ ] How to use =bibtex-completion-fallback=
- [ ] Or use =biblio.el=

Getting bibtex entries from crossref and much more.

Problem: MathSciNet uses author title... not a "everywhere" query.
The package bibretrive is a mess, but it works.
To unify engines: Added action "Fallback options" to "ivy-bibtex" to look for MathSciNet using bibretrive
Once it is done, add the correspnding entrie to =bibtex-completion-fallback-options=

#+begin_src elisp :tangle no
;; Use the same shortcut to search bib items on internet for all the engines.
(after! bibtex-completion
  (setq bibtex-completion-fallback-options
        (append
         '(("MathSciNet                                (bibretrive.el)"
            . (lambda (search-expression) (bibretrieve)))
           ("Download                                  (scihub.el)"
            . (lambda (search-expression) (call-interactively 'scihub))))
         bibtex-completion-fallback-options)
        ;; CrossRef gives priority to queries that include an email address.
        biblio-crossref-user-email-address user-mail-address
        ;; bibtex-completion-bibliography "~/Dropbox/bibliography/my.bib"
        bibtex-completion-additional-search-fields '(keywords tags)
        bibtex-completion-pdf-extension '(".pdf" ".djvu")
        ;; ivy-bibtex-default-action 'ivy-bibtex-insert-citation
        ;; bibtex-completion-pdf-field "file" ;; pdf assoc a bib entry by field "file =
        ;; {/path/to/article.pdf;:/path2...}"
        ;; bibtex-completion-display-formats
        ;; '((t . "${author:25} ${year:4} ${title:*} ${=has-pdf=:1} ${keywords:10} ${=type=:3}"))
        )
  ;; Show entries in the same order as in bibtex file
  (advice-add 'bibtex-completion-candidates
              :filter-return 'reverse)
  )
;; Using bibtex-completion fallbacks in citar via embark:
(after! citar
  (defun citar-fallback (search-expression)
    "Select a fallback option for SEARCH-EXPRESSION.
  This is meant to be used as an embark-action in `citar-*` commands."
    (let* ((candidate (consult--read bibtex-completion-fallback-options
                                     :prompt "Fallback options: "
                                     ;; :caller 'ivy-bibtex-fallback
                                     ))
           (fallback (cdr (assoc candidate bibtex-completion-fallback-options))))
      (bibtex-completion-fallback-action fallback search-expression)))

  (define-key citar-map (kbd "s") #'("Fallback options" . citar-fallback))
  )
#+end_src

*** COMMENT ox-bibtex
Maintaining notes.org
#+begin_src elisp :tangle no
(after! org
  (require 'ox-bibtex))
#+end_src

** Completion environment
[[file:~/.emacs.d/modules/completion/vertico/README.org::*Table of Contents][Vertico module's README]]
*** Bindings
#+begin_src elisp :tangle no
;; https://githubmemory.com/repo/minad/vertico/issues/156
(defun my/vertico-insert-or-exit ()
  "Insert the candidate if it's a directory, otherwise select it and exit."
  (interactive)
  (let ((cand (vertico--candidate)))
    (if (and (>= vertico--index 0)
             (equal (substring cand -1) "/"))
        (vertico-insert)
      (vertico-exit))))

(map! :after vertico :map minibuffer-mode-map
      ;; Motion: LOWER from keyboard
      ;; "M-j" #'ivy-next-line
      ;; "M-k" #'ivy-previous-line
      ;;
      ;; Finish
      ;; "<right>"  #'ivy-alt-done
      "<right>"  #'my/vertico-insert-or-exit
      ;; ";"   #'ivy-immediate-done
      "<return>" #'vertico-exit-input
      ;;
      ;; History
      ;; "<next>"   #'next-history-element
      ;; "<prior>"  #'previous-history-element
      ;; "M-j"      #'next-history-element
      ;; "M-k"      #'previous-history-element
      ;; "M-j"      #'ivy-next-history-element
      ;; "M-k"      #'ivy-previous-history-element
      ;;
      ;; Embark
      ;; "C-;" #'embark-act
      ;; "M-o" #'ivy-dispatching-done
      ;;
      ;; ;; Interaction
      ;; "M-w"      #'ivy-yank-word
      ;; "C-o"      #'hydra-ivy/body
      ;; "C-<"      #'ivy-minibuffer-shrink
      ;; "C->"      #'ivy-minibuffer-grow
      ;; "M-m"      #'ivy-mark
      ;; Security
      ;; "<return>" #'nil
      )
#+end_src

#+RESULTS:
*** Find files recursively

With prefix argument all files (hidden, .gitignoreds, ....) are shown as candidates.

#+begin_src elisp
(defun brust-vertico/find-file-in--add-hidden-files-option (orig-fun &rest args)
  (if current-prefix-arg
      (let ((+vertico-consult-fd-args "fdfind --color=never -i -H -I --regex "))
        (apply orig-fun args))
    (apply orig-fun args)))

(advice-add '+vertico/find-file-in :around #'brust-vertico/find-file-in--add-hidden-files-option)
;; (advice-remove '+vertico/find-file-in #'brust-vertico/find-file-in-add-hidden-files-option)

(defun brust-doom-project-find-file--add-hidden-files-option (orig-fun &rest args)
  (and current-prefix-arg
      (+vertico/find-file-in default-directory)
      t))

;; (advice-remove 'doom-project-find-file #'brust-doom-project-find-file--add-hidden-files-option)
;; (advice-add 'doom-project-find-file :around #'brust-doom-project-find-file--add-hidden-files-option)
(advice-add 'doom-project-find-file :before-until #'brust-doom-project-find-file--add-hidden-files-option)
#+end_src

*** Jumping to specific dirs
#+begin_src elisp :tangle no
;; This is equivalent to #'+default/find-file-under-here
;; (defun brust-counsel-fzf-dir nil
;;   "fzf find file selecting a directory"
;;   (interactive)
;;   (let ((μdir (brust-ivy-read-directory-name)))
;;     (counsel-fzf nil μdir (concat "fzf in " μdir ": "))))

(defvar brust-find-file-recursively-default-dirs-alist
  '(("~/" . "Home")
    ("~/Dropbox/" . "Dropbox")
    ("~/.emacs.d/" . "emacs.d")
    ("~/.doom.d/" . ".doom.d"))
  "Cons list of `(dir . name)' to auto-create fzf searches in.")

(cl-loop for dirname in brust-find-file-recursively-default-dirs-alist do
         ;; (message "dir %s, name %s" (car dirname) (cdr dirname))
         (let* ((dir (car dirname))
                (name (cdr dirname))
                (bind (downcase (substring name 0 1)))
                (fun-name (intern (format "brust-find-file-recursively-%s" (downcase name)))))
           ;; (message "dir %s, name %s" dir name)
           (fset fun-name
                 `(lambda nil (interactive)
                    (doom-project-find-file ,dir)))
           (map! (:leader (:prefix "f" (:prefix "z"
                                        :desc name bind fun-name))))))
#+end_src

** TODO File templates

TODO Add templates for Julia...

#+begin_src elisp
;; +file-templates-dir

;; It is run once when upgrading or syncing doom (when .emacs.d/module/ folder might be modified).
;; cp -r ~/.doom.d/local/templates/* ~/.emacs.d/modules/editor/file-templates/templates
;; alias doom-sync='~/.emacs.d/bin/doom sync && \
;;     cp -r ~/.doom.d/local/templates/* ~/.emacs.d/modules/editor/file-templates/templates && \
;;     echo > Templates sync'
;; alias doom-up='~/.emacs.d/bin/doom upgrade && doom-sync'

(set-file-template! "[.]sing" :trigger "__sing" :mode 'c++-mode)
(set-file-template! "[.]tex" :trigger "__tex" :mode 'latex-mode)
(set-file-template! "[.]jl" :trigger "__jl" :mode 'julia-mode)
#+end_src

#+begin_src bash :tangle no
cp -r ~/.doom.d/local/templates/* ~/.emacs.d/modules/editor/file-templates/templates
#+end_src

** High light TODOS
*** Making Items
You can make a TODO item by simply writing
+ =TODO=
  For things that need to be done, just not today.
+ =HACK=
  For tidbits that are unconventional and not intended uses of the
  constituent parts, and may break in a future update.
+ =FIXME=
  For problems that will become bigger problems later if not fixed ASAP.
+ =REVIEW=
  for things that were done hastily and/or hasn't been thoroughly
  tested. it may not even be necessary!
+ =NOTE=
  For especially important gotchas with a given implementation,
  directed at another user other than the author.
+ =DEPRECATED=
  For things that just gotta go and will soon be gone.
+ =BUG=
  For a known bug that needs a workaround
+ =XXX=
  For warning about a problematic or misguiding code

*** Keybindings
| keybind   | description                      |
|-----------+----------------------------------|
| =]t=      | go to next TODO item             |
| =[t=      | go to previous TODO item         |
| =SPC p t= | show all TODO items in a project |
| =SPC s p= | search project for a string      |
| =SPC s b= | search buffer for string         |

*** Config
#+begin_src elisp
(after! hl-todo
  (setq hl-todo-keyword-faces
        `(
          ("TODO"     . '(warning bold))
          ("DONE"     . "#afd8af")
          ("DOING"    . "#4169e1")
          ("CANCELED" . "#708090")
          ))
  )
;; TODO DONE DOING CANCELED
#+end_src

** TODO Rotate text
Rotate text under cursor under pre-establish patterns
For example, var1, var2, ... varN
See [[https://github.com/debug-ito/rotate-text.el/blob/master/rotate-text.el][Rotate Text]]

** Visual fill mode

#+begin_src elisp
(add-hook! 'emacs-startup-hook
  (+global-word-wrap-mode +1)
  (add-to-list '+word-wrap-disabled-modes 'emacs-lisp-mode)
  (add-to-list '+word-wrap-visual-modes 'org-mode))
#+end_src

** COMMENT Workspaces (presp)
#+begin_src elisp :tangle no
(setq persp-save-dir (expand-file-name "~/.doom.d/local/workspaces/")
      persp-auto-save-persps-to-their-file-before-kill t)
;; persp-save-to-file-by-names
#+end_src

* Bindings
#+begin_src elisp
(map!
 ;; s- commands: commands executed several times AND in several distinct modes.
 "s-s"      #'save-buffer
 "s-w"      #'evil-window-next
 ;; "s-c"      #'close-quoted-open-paren-right-or-left-end-of-line
 "s-c"      #'close-quoted-open-paren-right-or-left
 ;; "s-SPC"    #'brust-cycle-whitespace ;; I am used to 'g SPC'
 "s-h"      #'recenter-top-bottom
 ;; "s-f"      #'flyspell-correct-previous ;; Learning to use z=
 ;; s- motion command
 "s-j"      #'evil-scroll-down
 "s-k"      #'evil-scroll-up
 ;; Cycling in kill-ring
 ;; "C-P"      #'brust-evil-paste-pop-backwards ;; see C-n
 "M-p"      #'consult-yank-pop
 ;; :ier "M-i" #'evil-normal-state ;; it was tab-to-tab-stop
 ;; Now I use evil-escape (equivalent to key-chords jk kj) Press them a single key!

 ;; Insert mode
 :i "C-,"   #'+spell/correct
 ;; Normal mode workarounds (keep it to minimum)
 ;; :n "u"     #'emacs-undo ;; now undo works fine
 :nim "C-e" #'doom/forward-to-last-non-comment-or-eol
 :n "q"     #'kill-current-buffer
 :n "Q"     #'mark-whole-buffer ;; was undefined
 ;; TODO Take care of org-mode?
 ;; I move by paragraphs more then by sentences
 :mvn "{"     #'evil-backward-sentence-begin
 :mvn "}"     #'evil-forward-sentence-begin
 :mvn "("     #'evil-backward-paragraph
 :mvn ")"     #'evil-forward-paragraph

 ;; :nvmro "w" #'evil-backward-word-begin
 ;; :nvmro "W" #'evil-backward-WORD-begin
 ;; :n "H"     #'recenter-top-bottom ;; There is no difference with s-h
 ;; More handy TABs (From Hlissner)
 :n [tab] (general-predicate-dispatch nil
            (fboundp 'evil-jump-item)
            #'evil-jump-item)

 :v [tab] (general-predicate-dispatch nil
            (and (bound-and-true-p yas-minor-mode)
                 (or (not (memq (char-after) (list ?\( ?\[ ?\{ ?\} ?\] ?\))))))
            #'yas-insert-snippet
            (fboundp 'evil-jump-item)
            #'evil-jump-item)
 ;; Personal extensions
 ;; "<f2>"  #'brust-correct-prev-spelling
 "<f5>"  #'consult-kmacro
 "<f9>"  #'mu4e
 "<f10>" #'magit-status
 :n "g SPC" #'brust-cycle-whitespace ;; It was unbind
 (:prefix "z"
  :n "j" #'brust-correct-prev-spelling
  :n "k" #'brust-correct-prev-spelling)
 ;; Binding for buffers
 (:map doom-leader-buffer-map
  ;; :desc "Ibuffer"     :n "i" #'+ibuffer/open-for-current-workspace
  :desc "Ibuffer all" :n "i" #'ibuffer)
 (:leader
  :desc "locleader" "SPC" nil ;; Unbind "SPC SPC"
  :desc "Delete other windows" "w 0" #'delete-other-windows
  ;; :desc "Rotate anticlockwise" "w a" #'rotate-frame-anticlockwise
  ;;
  ;; My global bindings of Laura: functions used everywhere but not so often.
  (:prefix ("l" . "BMO")
   :desc "narrow generic"    "n"    #'endless/narrow-or-widen-dwim
   :desc "code screenshot"   "p"    #'screenshot
   :desc "visual rx replace" "%"    #'vr/query-replace
   :desc "macro insert str"  "<f3>" #'kmacro-query-my
   :desc "ispell & abbrev"   "i"    #'endless/ispell-word-then-abbrev
   "1" #'zoom-out ;; enlarge font
   "2" #'zoom-in ;; reduce font
   ))
 )
#+end_src

* My functions
** COMMENT Add blank pages to a pdf

#+BEGIN_SRC elisp :tangle no
(defun brust-pdf-add-blank-pages (-file init-page)
  (interactive
   (list  (read-file-name "Pdf to modify: ")
          (read-number "Page to start adding blank pages: ")))
  (let (-num -page (i init-page) -commstr)
    (with-temp-buffer
      (insert (shell-command-to-string (format "pdftk %s dump_data" -file)))
      (goto-char (point-min))
      (re-search-forward "NumberOfPages: \\([0-9]+\\)$" nil t)
      (setq -num (- (string-to-number (match-string 1)) i))
      (setq -page
            (if (re-search-forward "PageMediaDimensions: \\([0-9]+\\) \\([0-9]+\\)$" nil t)
                (concat (match-string 1) "x" (match-string 2))
              "a4")))
    (setq -commstr
          (concat (format "A1-%d " i)
                  (cl-loop repeat -num
                           concat (format "B1 A%d " (setq i (1+ i))))))
    (let ((-blanche (concat (file-name-directory -file) "pageblanche.pdf"))
          (-mod (concat (file-name-directory -file) "mod_" (file-name-base -file) ".pdf"))
          (-out (concat (file-name-directory -file) "print_" (file-name-base -file) ".pdf")))
      (shell-command (format "convert xc:none -page %s %s" -page -blanche))
      (shell-command (format "pdftk A=%s B=%s cat %s output %s" -file -blanche -commstr -mod))
      (shell-command (format "rm %s" -blanche)))))
;; (shell-command (format "pdfnup %s --nup 2x1 --landscape --outfile %s" -mod -out))
;; (shell-command (format "rm %s && rm %s" -mod -blanche)))))
#+END_SRC

** Advise once

#+begin_src elisp
(defun advice-once (symbol where function &optional props)
  (let ((new-function (intern (concat (symbol-name function) "-advice-once"))))
    (fset new-function `(lambda (&rest _)
                          (call-interactively ',function)
                          (advice-remove ',symbol #',new-function)))
    (advice-add symbol where new-function props)))
#+end_src

** By five

#+BEGIN_SRC elisp
(defun brust-by-five (-function args)
  (funcall-interactively -function (if (numberp args) (* 5 args) 5)))
#+END_SRC

** Change font size
#+begin_src elisp
(defun zoom-in nil
  (interactive)
  (set-face-attribute 'default nil :height (+ (face-attribute 'default :height) 10)))

(defun zoom-out nil
  (interactive)
  (set-face-attribute 'default nil :height (- (face-attribute 'default :height) 10)))
#+end_src

** Close<->open parents
*** Parenthesis syntax.
#+BEGIN_SRC elisp
(defconst all-paren-syntax-table
  (let ((table (make-syntax-table)))
    (modify-syntax-entry ?{  "(}" table)
    (modify-syntax-entry ?}  "){" table)
    (modify-syntax-entry ?\( "()" table)
    (modify-syntax-entry ?\) ")(" table)
    (modify-syntax-entry ?\[ "(]" table)
    (modify-syntax-entry ?\] ")[" table)
    (modify-syntax-entry ?\\ "'"  table)
    ;; (modify-syntax-entry ?\< "(>" table)
    ;; (modify-syntax-entry ?\> ")<" table)
    table)
  "A syntax table giving all parenthesis parenthesis syntax.")
#+END_SRC

*** Generic function
#+BEGIN_SRC elisp
(defun close-quoted-open-paren (args dir)
  "dir=0 -> right, dir=1 -> left"
  (with-syntax-table all-paren-syntax-table
    (cl-loop repeat args do
             (let* ((i dir)
                    (pos (save-excursion (up-list (1- (* 2 dir))) (point)))
                    (closing (matching-paren (char-after (- pos dir)))))
               (while (eq (char-before (- pos i)) ?\\)
                 (setq i (1+ i)))
               (cl-loop repeat (- i dir) do
                        (progn
                          (unless (or (eolp) (evil-insert-state-p)) (forward-char +1))
                          (insert "\\")
                          ))
               (unless (or (eolp) (evil-insert-state-p)) (forward-char +1))
               (insert closing)
               (backward-char (* dir i)))))
  t)
#+END_SRC

*** By right
#+BEGIN_SRC elisp
(defun close-quoted-open-paren-right (&optional args)
  (interactive "P")
  (close-quoted-open-paren (if (numberp args) args 1) 0))

(defun close-all-open-paren-right nil
  (interactive)
  (while (ignore-errors (close-quoted-open-paren-right))))

#+END_SRC
*** By left
#+BEGIN_SRC elisp
(defun close-quoted-open-paren-left (&optional args)
  (interactive "P")
  (close-quoted-open-paren (if (numberp args) args 1) 1))

(defun close-all-open-paren-left nil
  (interactive)
  (while (ignore-errors (close-quoted-open-paren-left))))
#+END_SRC
*** By right or left
#+BEGIN_SRC elisp
(defun my-texmathp nil
  (interactive)
  (when (texmathp)
    (let ((pnt (point))
          (p (ignore-errors
               (goto-char (cdr texmathp-why))
               (sp-forward-sexp 1))))
      (goto-char pnt)
      p)))

(defun close-quoted-open-paren-right-or-left (&optional args)
  (interactive "P")
  (or args (setq args 1))
  (cl-loop repeat args do
           (if (and (fboundp 'texmathp)
                    (my-texmathp))
               (unless (and (ignore-errors (close-quoted-open-paren-right))
                            (if (my-texmathp) t (delete-char -2) nil))
                 (unless (and (ignore-errors (close-quoted-open-paren-left))
                              (if (my-texmathp) t (delete-char 2) nil))))
             (unless (ignore-errors (close-quoted-open-paren-right))
               (unless (ignore-errors (close-quoted-open-paren-left)))))))

(defun close-quoted-open-paren-right-or-left-end-of-line (&optional args)
  (interactive "P")
  (when (not (string= (thing-at-point 'char) " ")) (move-end-of-line 1))
  (close-quoted-open-paren-right-or-left args))
#+END_SRC

** Customize face at point

    A handy function for customization (from Singular web page).

#+BEGIN_SRC elisp
(defun customize-face-at-point nil
  "Customize face which point is at."
  (interactive)
  (let ((face (get-text-property (point) 'face)))
    (if face
        (customize-face face)
      (message "No face defined at point"))))

#+END_SRC
** Delete region advise
#+begin_src elisp
(defun brust-return-buffer-substring-advice (orig-fun &rest args)
  "Same as 'delete-region' but returns the deleted string"
  (let ((str (apply 'buffer-substring args)))
    (apply orig-fun args)
    str))

(advice-add 'delete-region :around #'brust-return-buffer-substring-advice)
#+end_src

** Double Capitals
    Convert words in DOuble CApitals to Single Capitals.
    [[https://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type][From StackExange]]

*** The function
#+BEGIN_SRC elisp
(defun brust-dcaps-to-scaps nil
  (save-excursion
    (let ((end (point)))
      (and (= -3 (skip-syntax-backward "w"))
           (let (case-fold-search)
             (looking-at-p "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
           (capitalize-region (point) end)))))

(defun dcaps-to-scaps nil
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (when (= ?w (char-syntax (char-before)))
    (brust-dcaps-to-scaps)))

(defun dcaps-to-scaps-notinmath nil
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (when (and (= ?w (char-syntax (char-before)))
             (not (texmathp)))
    (brust-dcaps-to-scaps)))
#+END_SRC
*** New minor mode
#+BEGIN_SRC elisp
(defun brust-dcaps-to-scaps-notinmath-p nil
  (or (derived-mode-p 'latex-mode)
      (eq major-mode 'org-mode)))

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter ("") ;; String to show in mode-line
  (if dubcaps-mode
      (if (brust-dcaps-to-scaps-notinmath-p)
          (add-hook 'post-self-insert-hook #'dcaps-to-scaps-notinmath nil 'local)
        (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local))
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps-notinmath 'local)))
#+END_SRC

*** Activation
This is needed in =config.el=.
#+BEGIN_SRC elisp
(add-hook 'text-mode-hook #'dubcaps-mode)
#+END_SRC
** Eval elips blocks in org mode

#+begin_src elisp
;; The following code is inspirated by
;; http://endlessparentheses.com/init-org-Without-org-mode.html
(defvar endless/init.org-message-depth 5
  "What depth of init.org headers to message at startup.")

;; I copy it here to avoid loading org-babel ;)
(defvar brust-endless/org-babel-src-block-regexp
  (concat
   ;; (1) indentation                 (2) lang
   "^\\([ \t]*\\)#\\+begin_src[ \t]+\\([^ \f\t\n\r\v]+\\)[ \t]*"
   ;; (3) switches
   "\\([^\":\n]*\"[^\"\n*]*\"[^\":\n]*\\|[^\":\n]*\\)"
   ;; (4) header arguments
   "\\([^\n]*\\)\n"
   ;; (5) body
   "\\([^\000]*?\n\\)??[ \t]*#\\+end_src")
  "Regexp used to identify code blocks.")

(defvar brust-endless/org-eblocks-lang
  '("elisp"
    "emacs-lisp")
  "List of strings for Elisp language")

(defun brust-endless/org-eval-eblocks (µcode &optional µinit µfile-p µheader-depth μfun)
  "Eval the SRC blocks of elisp code in µcode which is the name of a file or a string where are the blocks.
µfile-p has to be t if µcode is a file and nil otherwise.
When µcode is a file, if µinit is nil eval whole file, if it is a string, eval just that header and µheader-depth has to be its depth (nil means 1).
Subtrees under a COMMENTed header are not evaluated."
  (or µheader-depth (setq µheader-depth 1))
  (with-temp-buffer
    (insert
     (if µfile-p
         (brust-endless/org-eval-eblocks-get-code µcode µinit µfile-p µheader-depth)
       µcode))
    (brust-endless/org-eval-eblocks-delete-commented-subtrees)
    (goto-char (point-min))
    (cl-flet ((funeval (or μfun 'eval-region)))
      (let (pheader neblock)
        (while (not (eobp))
          (cond
           ((looking-at "^\\(\\*+\\) \\(.*\\)$")
            (setq pheader (match-string 2)
                  neblock 1)
            (message "%s" (match-string 0)))
           ((looking-at brust-endless/org-babel-src-block-regexp)
            ;; (when (memq (match-string 2) brust-endless/org-eblocks-lang)
            (funeval (match-beginning 5) (match-end 5))
            (message "%s :: %d" pheader neblock)
            (setq neblock (1+ neblock))
            ;; (goto-char (match-end 5))
            ))
          (forward-line +1))))
    (message "=========== ================================== ===========")
    (message "=========== !! Be happy, everything is load !! ===========")
    (message "=========== ================================== ===========")))


(defun brust-eval-track-time (beg end)
  (let ((sec (car (benchmark-run (eval-region beg end)))))
    (message "(sec: %.3f)" sec)))

(defun brust-endless/org-eval-eblocks-delete-commented-subtrees nil
  (interactive)
  (goto-char (point-min))
  (let ((case-fold-search nil)
        beg end
        hdepth)
    (while (re-search-forward "^\\(\\*+\\) COMMENT .*$" nil t)
      (setq beg (match-beginning 0)
            hdepth (- (match-end 1) (match-beginning 1))
            end (if (re-search-forward (format "^\\*\\{1,%d\\} " hdepth) nil t)
                    (match-beginning 0)
                  (point-max)))
      (delete-region beg end)
      (goto-char beg))))

(defun brust-endless/org-eval-eblocks-get-code (µcode &optional µinit µfile-p µheader-depth)
  (with-temp-buffer
    (insert-file-contents µcode)
    (if (not µinit) (buffer-string)
      (goto-char (point-min))
      (let ((beg
             (if (re-search-forward
                  (format (concat
                           "^\\*\\{%d\\}"
                           "\\( +\\| +COMMENT +\\)"
                           "\\(\\|TODO \\|DONE \\|CANCELED \\|DOING \\)%s")
                          µheader-depth µinit)
                  nil t)
                 (match-beginning 0)
               (user-error "Header not found")))
            (end
             (if (re-search-forward (format "^\\*\\{1,%d\\} " µheader-depth) nil t)
                 (match-beginning 0)
               (point-max))))
        (buffer-substring-no-properties beg end)))))

;; (when (< 24 emacs-major-version)
;;   (brust-endless/org-eval-eblocks "~/.doom.d/MyConfig.org" "init.el" t))

#+end_src

** COMMENT Read directory

This command does the trick now: =(consult-dir--pick "In directory: ")=

#+begin_src elisp :tangle no
(defun brust-ivy-read-directory-name (&optional initial-input action initial-directory)
  "Select a directory using `ivy-read'."
  (interactive)
  (let ((default-directory (or initial-directory
                               (if (eq major-mode 'dired-mode)
                                   (dired-current-directory)
                                 default-directory))))
    (ivy-read "Directory " #'read-file-name-internal
              :matcher #'counsel--find-file-matcher
              :predicate #'file-directory-p
              :initial-input initial-input
              :action action
              :preselect (counsel--preselect-file)
              :require-match 'confirm-after-completion
              :history 'file-name-history
              :keymap counsel-find-file-map
              :caller 'brust-ivy-read-directory-name)))
#+end_src

** Line by line

#+begin_src elisp
(defun brust-apply-function-line-by-line (FUNCTION &rest ARGS)
  "Executes function FUNCTION, from point-min, and moves forward one line. Repeat until end of buffer."
  (save-excursion
    (goto-char (point-min))
    (while (not (eobp))
      (apply FUNCTION ARGS)
      (forward-line +1))))
#+end_src

** Macro query
#+BEGIN_SRC elisp
(defun kmacro-query-my (arg)
  "Prompt for input using minibuffer during kbd macro execution.
   With prefix argument, allows you to select what prompt string to use.
   If the input is non-empty, it is inserted at point."
  (interactive "P")
  (let* ((prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
         (input (minibuffer-with-setup-hook (lambda nil (kbd-macro-query t))
                  (read-from-minibuffer prompt))))
    (unless (string= "" input) (insert input))))
#+END_SRC

** Mouse wheel
    Mouse wheel: try it with S and C
*** Functions
#+BEGIN_SRC elisp
(defun up-slightly (args) (interactive "p") (brust-by-five #'scroll-up args))
(defun down-slightly (args) (interactive "p") (brust-by-five #'scroll-down args))

(defun up-one nil (interactive) (scroll-up 1))
(defun down-one nil (interactive) (scroll-down 1))

(defun up-a-lot nil (interactive) (scroll-up))
(defun down-a-lot nil (interactive) (scroll-down))

#+END_SRC

*** Keybindings
#+BEGIN_SRC elisp
(global-set-key [mouse-4] 'down-slightly)
(global-set-key [mouse-5] 'up-slightly)

(global-set-key [S-mouse-4] 'down-one)
(global-set-key [S-mouse-5] 'up-one)

(global-set-key [C-mouse-4] 'down-a-lot)
(global-set-key [C-mouse-5] 'up-a-lot)
#+END_SRC

** Narrow or widen dwin
 There's a nice helper from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Parentheses]] that defines a do-what-I-mean version
 of the narrow-or-widen so I don't have to keep remembering which is which.
#+BEGIN_SRC elisp
(defun endless/narrow-or-widen-dwim (args)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p)
              (not args))
         (widen)
         (let ((recenter-redisplay t))
           (recenter nil)))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end))
         (deactivate-mark)
         (goto-char (point-min)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if
         ;; you don't want it.
         (cond ((ignore-errors (org-edit-special) t))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((and (derived-mode-p 'latex-mode)
              (ignore-errors (LaTeX-narrow-to-environment))))
        ((derived-mode-p 'emacs-lisp-mode)
         (narrow-to-defun))
        (t
         (brust-narrow-to-paragraph))))
#+END_SRC

** Open my.org
#+begin_src elisp
(defun brust-open-my-org nil
  (interactive)
  (find-file (expand-file-name (concat org-directory  "my.org"))))
#+end_src

** Prompt in Singular... Non-editable
#+begin_src elisp
(defvar brust-math-software-buffers-prompts
  '(("*julia*"    . "^julia>")
    ("*singular*" . "^>"))
  "List of cons with buffer names runing some math software and a regex for its promp string")

(defun brust-math-software-intangify-buffer-text (-regexp beg end)
  "Set cursor-intangible property to all buffer text maching regular expresion `-regexp` between `beg` and  `end`"
  (save-excursion
    (goto-char beg)
    (save-match-data
      (while (re-search-forward -regexp end t)
        (add-text-properties (1- (match-beginning 0)) (match-end 0) '(cursor-intangible t rear-nonsticky nil))))))

(defun brust-math-software-intangify-cursor-on-prompt (beg end length)
  "Set cursor-intangible in math software buffers prompts"
  (let ((-prompt (cdr (assoc (buffer-name) brust-math-software-buffers-prompts))))
    (when -prompt
      (brust-math-software-intangify-buffer-text -prompt beg end))))

(defun brust-math-software-hookfun-to-intangify-prompt nil
  (cursor-intangible-mode 1)
  (add-hook 'after-change-functions #'brust-math-software-intangify-cursor-on-prompt nil t))
#+end_src

** RGB colors (get numbers)
*** Convert color's names
#+begin_src elisp
(defvar brust-colors-rgb-decimal-points 1 "Number of decimal points rounding RGB colors")
(defvar brust-colors-rgb-separator "," "SEPARATOR between numbers")

(defun brust-round (list-of-num)
  (let ((rounding (* 10 brust-colors-rgb-decimal-points)))
    (cl-loop for x in list-of-num
             collect (/ (fround (* rounding x)) rounding))))

(defun brust-colors-num-to-str (color)
  (mapconcat #'number-to-string color brust-colors-rgb-separator))

(defun brust-colors-insert-rgb (color)
  "Insert the RGB value 'num1,num2,num3' with num between 0 and 1"
  (insert (brust-colors-num-to-str (color-name-to-rgb color))))

(defun brust-colors-insert-rounded-rgb (color)
  "Insert the RGB value 'num1,num2,num3' rounded to `brust-colors-rgb-decimal-points' decimal points."
  (insert (brust-colors-num-to-str (brust-round (color-name-to-rgb color)))))

(defun brust-colors-kill-rgb (color)
  "Kill the RGB value 'num1,num2,num3' with num between 0 and 1"
  (kill-new (brust-colors-num-to-str (color-name-to-rgb color))))

(defun brust-colors-kill-rounded-rgb (color)
  "Kill the RGB value 'num1,num2,num3' rounded to `brust-colors-rgb-decimal-points' decimal points."
  (kill-new (brust-colors-num-to-str (brust-round (color-name-to-rgb color)))))

;; Copied from counsel.el to conver color name to hex.
(defun counsel-colors--name-to-hex (name)
  "Return hexadecimal RGB value of color with NAME.
Return nil if NAME does not designate a valid color."
  (when-let* ((rgb (color-name-to-rgb name))
              ;; Sets 2 digits per component.
              (hex (apply #'color-rgb-to-hex (append rgb '(2)))))
    (insert hex)))
#+end_src

*** Consult colors
#+begin_src elisp
(defvar consult-colors-history nil
  "History for `consult-colors-emacs' and `consult-colors-web'.")

;; No longer preloaded in Emacs 28.
(autoload 'list-colors-duplicates "facemenu")

(autoload 'consult--read "consult")

(defun consult-colors-emacs (color)
  "Show a list of all supported colors for a particular frame.\

You can insert or kill the name or hexadecimal RGB value of the
selected color."
  (interactive
   (list (consult--read (list-colors-duplicates (defined-colors))
                        :prompt "Emacs color: "
                        :require-match t
                        :category 'color
                        :history '(:input consult-colors-history)
                        )))
  (insert color))

;; Copied from counsel.el to get web colors.
(defun counsel-colors--web-alist ()
  "Return list of CSS colors for `counsel-colors-web'."
  (require 'shr-color)
  (let* ((alist (copy-alist shr-color-html-colors-alist))
         (mp  (assoc "MediumPurple"  alist))
         (pvr (assoc "PaleVioletRed" alist))
         (rp  (assoc "RebeccaPurple" alist)))
    ;; Backport GNU Emacs bug#30377
    (when mp (setcdr mp "#9370db"))
    (when pvr (setcdr pvr "#db7093"))
    (unless rp (push (cons "rebeccapurple" "#663399") alist))
    (sort (mapcar (lambda (cell)
                    (propertize (downcase (car cell))
                                'hex (downcase (cdr cell))))
                  alist)
          #'string-lessp)))

(defun consult-colors-web (color)
  "Show a list of all supported colors for a particular frame.\

You can insert or kill the name or hexadecimal RGB value of the
selected color."
  (interactive
   (list (consult--read (counsel-colors--web-alist)
                        :prompt "Color: "
                        :require-match t
                        :category 'color
                        :history '(:input consult-colors-history)
                        )))
  (insert color))
#+end_src

*** Embark actions
#+begin_src elisp
(after! embark
  (embark-define-keymap embark-consult-colors-actions
                        "Keymap for actions for `color' category."
                        ("h" '("Insert hex value". counsel-colors--name-to-hex))
                        ("r" '("Insert rRGB value" . brust-colors-insert-rounded-rgb))
                        ("g" '("Insert RGB value" . brust-colors-insert-rgb))
                        ("G" '("Kill RGB value". brust-colors-kill-rgb))
                        ("R" '("Kill rRGB value" . brust-colors-kill--rounded-rgb)))

  (add-to-list 'embark-keymap-alist '(color . embark-consult-colors-actions)))
#+end_src

*** Marginalized

Marginalized already defined a category =color= for which uses =marginalia-annotate-color=.
So, unless we create a new category (simply by defining new elements in it) we do NOT need to
add any register to marginalized.

#+begin_src elisp :tangle no
;; (add-to-list 'marginalia-annotator-registry
;;  '(consult-colors marginalia-annotate-color builtin none))
#+end_src

** Spelling
#+begin_src elisp
(defun brust-correct-prev-spelling nil
  (interactive)
  (save-excursion
    (+spell/previous-error)
    (+spell/correct)))
#+end_src

** Total number of lines
#+begin_src elisp
(defsubst brust--number-of-lines-current-buffer nil
  (let ((n (string-to-number
            (save-excursion
              (goto-char (point-max))
              (format-mode-line "%l")))))
    (s-trim
     (cond
      ((> n 1000000) (format "%7.1fM" (/ n 1000000.0)))
      ((> n 1000) (format "%7.1fk" (/ n 1000.0)))
      ;;((> n 100) (format "%7.1fh" (/ n 100.0)))
      (t (format "%8d" n))))))
#+end_src

** Vterm
*** Eval line or region
#+begin_src elisp
(defun brust-vterm--eval-string (string &optional paste-p)
  (with-current-buffer (process-buffer vterm--process)
    (vterm-send-string string paste-p)))

(defun brust-vterm--eval-buffer-substring (beg end &optional paste-p)
  (brust-vterm--eval-string (concat (s-trim (buffer-substring-no-properties beg end)) "\n") paste-p))

(defun brust-vterm--eval-region nil
  (brust-vterm--eval-buffer-substring (region-beginning) (region-end) 1))

(defun brust-vterm--eval-line nil
  (brust-vterm--eval-buffer-substring (line-beginning-position) (line-end-position)))
#+end_src

*** Launch or link a vterm buffer
#+begin_src elisp
(defun brust-vterm--link (proc-buffer origin-buffer)
  "Copies the value of the local variable `vterm--process' from buffer `proc-buffer' to buffer `origin-buffer'.
Then, in `origin-buffer' we can use such a process to execute code in terminal via ."
  (save-excursion
    (set-buffer proc-buffer)
    (let ((proc vterm--process))
      (set-buffer origin-buffer)
      (setq-local vterm--process proc))))

(defun brust-vterm--launch-and-link (origin-buffer sufix)
  "Launches a new instance of vterm in buffer `origin-buffer-sufix' and links its process to `origin-buffer'."
  (save-excursion
    (let ((proc-buffer (concat origin-buffer sufix)))
      (vterm-other-window proc-buffer)
      (brust-vterm--link proc-buffer origin-buffer))))
#+end_src

** COMMENT Word count
#+BEGIN_SRC elisp :tangle no
(defun brust-wc-get-word-count-list-of-current-project nil
  (let ((project-master (expand-file-name (TeX-master-file t nil t))))
    (with-temp-buffer
      (call-process-shell-command
       (concat "texcount -opt="
               (expand-file-name "~/Dropbox/config/TeXcount-emacs.txt")
               " -dir="
               (file-name-directory project-master)
               " "
               project-master)
       nil t)
      (re-search-backward
       "new\\([0-9]+\\)w\\([0-9]+\\)im\\([0-9]+\\)dm\\([0-9]+\\)cd\\([0-9]+\\)h\\([0-9]+\\)file" nil t)
      (cl-loop for xx from 1 to 6
               if (= xx 3) collect (number-to-string (- (string-to-number (match-string-no-properties 3))
                                                        (string-to-number (match-string-no-properties 4))))
               else
               collect (match-string-no-properties xx)))))

(defun brust-wc-save-words nil
  (interactive)
  (let ((wc-sat (brust-wc-get-word-count-list-of-current-project)))
    (find-file (concat
                (file-name-directory (expand-file-name (TeX-master-file t nil t)))
                "wc-statistics.txt"))
    (goto-char (point-max))
    (insert "\n" (format-time-string "%x, %X, ")
            (cl-loop for xx in wc-sat
                     concat (concat xx ", ")))
    (save-buffer)
    (kill-buffer)))

(defun brust-wc-save-words-my-thesis nil
  (interactive)
  (find-file "~/Dropbox/Math/Doctorat_Laura/Thesis/master.tex")
  (brust-wc-save-words))
#+END_SRC

** White space edit
#+begin_src elisp
(defvar brust-inline-whitespace-regexp  " \t\v\f")
(defvar brust-whitespace-regexp  " \t\v\f\n")

(defun skip-white-space-forward (&optional point inline-p)
  (interactive)
  (skip-chars-forward (if inline-p
                          brust-inline-whitespace-regexp
                        brust-whitespace-regexp))
  (when point (constrain-to-field nil point))
  (point))

(defun skip-white-space-backward (&optional point inline-p)
  (interactive)
  (skip-chars-backward (if inline-p
                           brust-inline-whitespace-regexp
                         brust-whitespace-regexp))
  (when point (constrain-to-field nil point))
  (point))

(defun delete-white-space-forward (&optional start inline-p)
  (interactive)
  (let ((p0 (point)))
    (delete-region (or start p0) (skip-white-space-forward p0 inline-p))))

(defun delete-white-space-backward (&optional start inline-p)
  (interactive)
  (let ((p0 (point)))
    (delete-region (or start p0) (skip-white-space-backward p0 inline-p))))
#+end_src

** White space cycle
    This is a remake and merge of =cycle-spacing= =delete-blank-lines= and =xah-shrink-whitespaces=.

#+BEGIN_SRC elisp
(defvar brust-cycle-whitespace--context nil
  "Store context used in consecutive calls to `brust-cycle-whitespace' command.
       The first time `brust-cycle-whitespace' runs, it saves in this variable:
       the original point position, and the original spacing around point.")

(defun brust-cycle-whitespace nil
  (interactive)
  (let* ((p0 (point))
         (beg (skip-white-space-backward p0))
         (end (skip-white-space-forward p0))
         (indent (buffer-substring-no-properties
                  (skip-white-space-backward nil t)
                  end))
         (context (buffer-substring beg end))
         (nline (1- (length (split-string context "\n")))))
    (cond
     ((or (not (equal last-command this-command))
          (not brust-cycle-whitespace--context))
      ;; Special handling for case where there is no space at all.
      (cond ((< beg end)
             (setq brust-cycle-whitespace--context ;;Save for later.
                   (cons p0 context))
             (delete-region beg end)
             (when (and (< (1+ beg) end)   ;; more than one space
                        (< end (point-max))  ;; erase whitespace at eobp
                        (< (point-min) beg)) ;; and at bobp
               (insert
                (cond ((< nline 2) " ")
                      ((< nline 3) (concat "\n" indent))
                      (t (concat "\n\n" indent))))))
            (t ;; indent when it is called without surrounding whitespaces.
             (end-of-line)
             (brust-cycle-whitespace))))
     ;; Final call: (and (equal last-command this-command) (equal beg end))
     ((not (< beg end))
      (insert (cdr brust-cycle-whitespace--context))
      (goto-char (car brust-cycle-whitespace--context))
      (setq cycle-spacing--context nil))
     ;; Intermadiate calls (and (equal last-command this-command) (< beg end))
     (t
      (delete-region beg end)
      (insert
       (cond ((< nline 1) "")
             ((< nline 2) " ")
             ((< nline 3) (concat "\n" indent))
             (t (concat "\n\n" indent))))))))
;; (more-expansions #'(brust-cycle-whitespace)))

#+END_SRC

* TODO Org mode
** Config
#+BEGIN_SRC elisp
(after! org
  (setq
   ;; org-edit-src-auto-save-idle-delay 20
   org-src-window-setup #'current-window
   org-cycle-global-at-bob t
   org-return-follows-link t
   org-hide-leading-stars nil
   org-ellipsis " ↴")
  (add-hook! 'org-mode-hook
    (setq
     org-hide-leading-stars nil
     org-src-window-setup #'current-window))
  (map! :map org-mode-map
        "<" 'brust-org<
        (:localleader
         ;; "SPC" (kbd "C-c C-c")
         :desc "vterm-julia send" "SPC" #'brust-org-mode-vterm-julia-send-region-or-block
         :desc "vterm-julia launch new" "v" #'brust-org-mode-vterm-julia-link-or-launch-and-link
         :desc "Babel" "B" org-babel-map
         )))
#+END_SRC

** TODO Agenda
#+begin_src elisp
(after! org
  (setq org-agenda-files (quote ("~/Dropbox/Org/" "~/Dropbox/bibliography/notes.org"))
        org-agenda-todo-list-sublevels nil
        org-deadline-warning-days 3
        org-agenda-skip-scheduled-if-done 1
        org-agenda-skip-deadline-if-done 1
        org-agenda-skip-deadline-if-done 1
        org-agenda-custom-commands
        '(("h" "My agenda view"
           ((agenda "")
            (todo))))))
#+end_src
** Exports
*** LaTeX

#+TITLE: 27 Cubics containing the reciprocal variety
#+AUTHOR: Laura Brustenga Moncusí
#+PROPERTY: header-args :eval never-export :cache no
#+PROPERTY: header-args+ :session *ob-ess-julia* :exports both
#+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \usepackage{polyglossia}
#+LATEX_HEADER: \setmonofont{DejaVu Sans Mono}[Scale=MatchLowercase]
#+LATEX_HEADER: \usepackage{unicode-math}
#+LATEX_HEADER: \renewcommand{\P}{\mathbb{P}} % Projective space
#+LATEX_HEADER: \renewcommand{\O}{\mathcal{O}}   % Calligraphic E
#+LATEX_HEADER: \renewcommand{\S}{\mathbb{S}}     % linear space of symmetric matrices
#+LATEX_HEADER: \newcommand{\Cat}{\mathrm{Cat}}   % Catalecticant matrix
#+LATEX_HEADER: \newcommand{\PGL}{\mathrm{PGL}}     % Projective general linear group
#+LATEX_HEADER: \newcommand{\Adj}{\mathrm{Adj}} % Adjugate matrix
#+OPTIONS: toc:nil
#+begin_src elisp
(after! org
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-minted-langs '((ess-julia "julia")
                                 (julia-vterm "julia"))
        org-latex-pdf-process
        '("lualatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "lualatex -shell-escape -interaction nonstopmode -output-directory %o %f")
        org-latex-minted-options
        '(("breaklines" "")
          ;; ("escapeinside" "||")
          ("linenos" "")
          ("numbersep" "3pt")
          ("mathescape" "true")
          ;; ("gobble" "2")
          ("frame" "lines")
          ("framesep" "2mm")
          ;; ("fontsize" "\small")
          )))
#+end_src

** Captures
#+BEGIN_SRC elisp
(after! org
  (setq org-capture-templates
        (append
         org-capture-templates
         `(
           ;; New Email
           ("e" "TODO respond to email"
            entry
            (file+headline "~/Dropbox/Org/my.org" "ToDo Miscellaneous")
            "* TODO %^{Description}\n%A\n%?\n")
           ;; Ledger
           ("l" "Ledger")
           ("lb" "Bank"
            plain
            (file ,(format "~/Dropbox/Org/ledger-%s.dat" (format-time-string "%Y")))
            ,my/org-ledger-card-template
            :empty-lines 1
            :immediate-finish t)
           ("lc" "Cash"
            plain
            (file ,(format "~/Dropbox/Org/ledger-%s.dat" (format-time-string "%Y")))
            ,my/org-ledger-cash-template
            :empty-lines 1
            :immediate-finish t)
           ;; Hugo
           ("h" "Hugo post"
            entry
            ;; It is assumed that below file is present in `org-directory'
            ;; and that it has a "Blog Ideas" heading. It can even be a
            ;; symlink pointing to the actual location of all-posts.org!
            (file+olp "my.org" "Blog Ideas")
            (function org-hugo-new-subtree-post-capture-template))))))
#+END_SRC

*** Functions
**** Hugo
#+begin_src elisp
;; Populates only the EXPORT_FILE_NAME property in the inserted headline.
(defun org-hugo-new-subtree-post-capture-template ()
  "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
  (let* ((title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
         (fname (org-hugo-slug title)))
    (mapconcat #'identity
               `(
                 ,(concat "* TODO " title)
                 ":PROPERTIES:"
                 ,(concat ":EXPORT_FILE_NAME: " fname)
                 ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                 ":END:"
                 "%?\n")          ;Place the cursor here finally
               "\n")))
;; (defun org-hugo-new-subtree-post-capture-template ()
;;   "Returns `org-capture' template string for new Hugo post.
;; See `org-capture-templates' for more information."
;;   (let* ((title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
;;          (fname (org-hugo-slug title)))
;;     (mapconcat #'identity
;;                `(
;;                  ,(concat "* TODO " title)
;;                  ":PROPERTIES:"
;;                  ,(concat ":EXPORT_HUGO_BUNDLE: " fname)
;;                  ":EXPORT_FILE_NAME: index"
;;                  ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
;;                  ":END:"
;;                  "%?\n")                ;Place the cursor here finally
;;                "\n")))
#+end_src

**** Ledger
#+begin_src elisp
(defvar my/org-ledger-card-template
  "%(org-read-date) %^{Payee}
       Expenses:%^{Account}  €%^{Amount}
       Liabilities:DebidCard:Mediolanum"
  "Template for devid card transaction with ledger.")

(defvar my/org-ledger-cash-template
  "%(org-read-date) * %^{Payee}
       Expenses:%^{Account}  €%^{Amount}
       Assets:Cash:Wallet"
  "Template for cash transaction with ledger.")
#+end_src

** Code blocks templates
*** Delete unwanted
#+begin_src elisp
(after! org
  (setq org-structure-template-alist (delete '("e" . "example") org-structure-template-alist)
        ;; org-structure-template-alist (delete '("j" . "src ess-julia :results output :session *julia* :exports both") org-structure-template-alist)
        ;; org-structure-template-alist (delete '("jj" . "src ess-julia :results output") org-structure-template-alist)
        org-structure-template-alist (delete '("E" . "export") org-structure-template-alist)))
#+end_src

*** Add mines
#+begin_src elisp
(after! org
  (add-to-list 'org-structure-template-alist
               '("e" . "src elisp"))
  (add-to-list 'org-structure-template-alist
               '("E" . "example"))
  (add-to-list 'org-structure-template-alist
               '("b" . "src bash"))
  (add-to-list 'org-structure-template-alist
               '("L" . "LaTeX"))
  ;; Shortcut for "normal" session evaluation with verbatim output:
  ;; (add-to-list 'org-structure-template-alist
  ;;              '("jj" . "src julia"))
  (add-to-list 'org-structure-template-alist
               ;; '("j" . "src ess-julia :results output :session *julia* :exports both"))
               '("jj" . "src julia :results output"))
  ;; Shortcut for inline graphical output within a session:
  ;; (add-to-list 'org-structure-template-alist
  ;;              '("jpic" . "src ess-julia :results output graphics file :file FILENAME.png"))
  (add-to-list 'org-structure-template-alist
               '("jvterm" . "src julia-vterm :session"))
  ;; Shortcut for well-formatted org table output within a session:
  (add-to-list 'org-structure-template-alist
               '("jtab" . "src julia :results value table :colnames yes")))
#+end_src

*** < insert template
#+begin_src elisp
(defun brust-org< nil
  "Self insert command or expand org-insert-structure-template"
  (interactive)
  (if (or (region-active-p) (looking-back "^"))
      (progn
        (call-interactively 'org-insert-structure-template)
        (insert "\n")
        (backward-char 1))
    (self-insert-command 1)))
#+end_src

** Pretty headlines
#+begin_src elisp
(after! org
  (defun brust-org-mode-pretty-headers (keysymbol)
    (let ((key (car keysymbol))
          (symbol (cdr keysymbol)))
      `(,(format "^\\(\\*\\{%s\\}\\) " key)
        (1
         (progn (compose-region (match-beginning 1) (match-end 1) ,symbol) nil)
         append))))

  (font-lock-add-keywords            ;; A bit silly but my headers are now
   'org-mode                         ;; shorter, and that is nice canceled
   (mapcar #'brust-org-mode-pretty-headers
           '(("1" . "☰")
             ("2" . "☱")
             ("3" . "☲")
             ("4" . "☳")
             ("5" . "☴")
             ("6" . "☵")
             ("7" . "☶")
             ("8," . "☷")))))
#+end_src

** COMMENT ob languages
*** COMMENT ob-ess-julia
#+begin_src elisp :tangle no
;; Load ob-ess-julia and dependencies
(use-package! ob-ess-julia
  :after org
  :config
  ;; Add ess-julia into supported languages:
  (add-to-list 'org-babel-load-languages '(ess-julia . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
  ;; (org-babel-do-load-languages 'org-babel-load-languages
  ;;                              (append org-babel-load-languages
  ;;                                      '((ess-julia . t))))
  ;; Link this language to ess-julia-mode (although it should be done by default):
  ;; (setq org-src-lang-modes
  ;;       (append org-src-lang-modes '(("ess-julia" . ess-julia))))
  (setq org-src-lang-modes
        (append org-src-lang-modes '(("ess-julia" . "julia"))))
  )
#+end_src
*** COMMENT ob-julia-vterm

#+begin_src elisp :tangle no
;; Load ob-ess-julia and dependencies
(use-package! ob-julia-vterm
  :after (org julia-vterm)
  :config
  ;; Add ess-julia into supported languages:
  (add-to-list 'org-babel-load-languages '(julia-vterm . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
  (add-to-list 'org-babel-tangle-lang-exts '("julia-vterm" . "jl"))
  ;; (org-babel-do-load-languages 'org-babel-load-languages
  ;;                              (append org-babel-load-languages
  ;;                                      '((ess-julia . t))))
  ;; Link this language to ess-julia-mode (although it should be done by default):
  ;; (setq org-src-lang-modes
  ;;       (append org-src-lang-modes '(("ess-julia" . ess-julia))))
  )
#+end_src
*** COMMENT ob-julia
#+begin_src elisp :tangle no
(use-package! ob-julia
  :commands org-babel-execute:julia
  :config
  (setq org-babel-julia-command-arguments
        `("--sysimage"
          ,(when-let ((img "~/.local/lib/julia.so")
                      (exists? (file-exists-p img)))
             (expand-file-name img))
          "--threads"
          ,(number-to-string (- (doom-system-cpus) 2))
          "--banner=no")))
#+end_src

** COMMENT Pdf links org-pdftools
     Org links for pdfs
#+begin_src elisp :tangle no
(use-package org-pdfview
  :config ;;(setq org-pdftools-root-dir "~/Dropbox/bibliography/pdf")
  )
#+end_src

** COMMENT Ledgers
Mainly from [[https://www.reddit.com/r/emacs/comments/8x4xtt/tip_how_i_use_ledger_to_track_my_money/][Reddit discution]]
*** Config
#+BEGIN_SRC elisp :tangle no
(use-package! ledger-mode
  :mode ("\\.dat\\'"
         "\\.ledger\\'")
  :custom
  (ledger-clear-whole-transactions t)
  (add-hook 'ledger-mode-hook #'ledger-flymake-enable)
  (add-hook 'ledger-mode-hook #'company-mode)
  (ledger-post-auto-adjust-amounts t)
  :bind
  (:map ledger-mode-map
   ("C-c C-a" . brust-ledger-add-transaction)))

(with-eval-after-load 'ledger-mode
  (define-key ledger-mode-map [remap save-buffer] #'std::ledger::save))
#+END_SRC

*** Functions
#+BEGIN_SRC elisp :tangle no
(defun brust-ledger-add-transaction (&optional -date)
  "Add new transaction using `org-read-date'"
  (interactive)
  (ledger-add-transaction
   (or -date (org-read-date))
   nil)
  (insert "?\n    Assets:DebitCard")
  (cdlatex-position-cursor))

(defun std::ledger::save nil
  "First `ledger-mode-clean-buffer', then `save-buffer'."
  (interactive)
  (save-excursion
    (when (buffer-modified-p)
      (with-demoted-errors (ledger-mode-clean-buffer))
      (save-buffer))))

(defun brust-ledger-copy-transaction-from-extract nil
  "`-string' is a line of my bank extract in cvs format"
  (interactive)
  (let ((-entry
         (split-string
          (buffer-substring-no-properties (point-at-bol) (point-at-eol))
          "\,")))
    (switch-to-buffer "ledger-2021.dat")
    (brust-ledger-add-transaction
     (brust-from-eur-ame-date (nth 0 -entry)))
    (insert (capitalize (nth 1 -entry))
            "\n    ?  €"
            (nth 3 -entry))
    (cdlatex-position-cursor)))


(defun brust-from-eur-ame-date (-date)
  (let ((-new-date (split-string -date "/")))
    (concat (nth 2 -new-date)
            "-"
            (nth 1 -new-date)
            "-"
            (nth 0 -new-date))))
#+END_SRC

** Eval julia code blocks in vterm
*** Send region or line
#+begin_src elisp
(defun brust-org-mode-vterm-julia-send-region-or-line nil
  (interactive)
  (org-babel-when-in-src-block
   (brust-julia--ensure-vterm-process-alive)
   (if (use-region-p)
       (brust-vterm--eval-region)
     (brust-vterm--eval-line))))
#+end_src

*** Send region or block or header
#+begin_src elisp
(defun brust-org-mode-vterm-julia--eval-block nil
  (org-babel-when-in-src-block
   ;; Format block-info = (language body arguments switches name start coderef)
   (let* ((block-info (org-babel-get-src-block-info t))
          ;; (lang (car block-info))
          (body (nth 1 block-info)))
     (brust-vterm--eval-string (concat body "\n") 1))))

(defun brust-org-mode-vterm-julia-send-region-or-block nil
  (interactive)
  (brust-julia--ensure-vterm-process-alive)
  (cond ((use-region-p) (brust-vterm--eval-region))
        ((org-at-heading-p) (brust-endless/org-julia--eval-header))
        (t (brust-org-mode-vterm-julia--eval-block))))
#+end_src

*** Eval all blocks under current header
#+BEGIN_SRC elisp
;; Julia blocks
(defun brust-endless/org-julia--eval-header nil
  (save-excursion
    (org-narrow-to-subtree)
    ;; (brust-endless/org-eval-eblocks-delete-commented-subtrees)
    ;; (goto-char (point-min))
    (while (not (eobp))
      (when (looking-at brust-endless/org-babel-src-block-regexp)
        (brust-vterm--eval-buffer-substring (match-beginning 5) (match-end 5) 1))
      (forward-line +1))
    (widen)))

;; (brust-endless/org-eval-eblocks
;;  nil
;;  nil
;;  nil
;;  'brust-vterm--eval-buffer-substring))
#+END_SRC

** Eval elisp blocks
#+begin_src elisp
;; Elisp blocks
(defun brust-endless/org-eval-current-header nil
  (interactive)
  (brust-endless/org-eval-eblocks
   (and (org-copy-subtree)
        (pop kill-ring))))
#+end_src
** Import other formats
Use pandoc to import files in .mw, .docs, ...
#+begin_src elisp
(use-package! org-pandoc-import :after org)
#+end_src
** COMMENT Org Ref
#+begin_src elisp :tangle no
(use-package! org-ref

  ;; this bit is highly recommended: make sure Org-ref is loaded after Org
  :after org

  ;; Put any Org-ref commands here that you would like to be auto loaded:
  ;; you'll be able to call these commands before the package is actually loaded.
  :commands
  (org-ref-cite-hydra/body
   org-ref-bibtex-hydra/body)

  ;; if you don't need any autoloaded commands, you'll need the following
  ;; :defer t

  ;; This initialization bit puts the `orhc-bibtex-cache-file` into `~/.doom/.local/cache/orhc-bibtex-cache
  ;; Not strictly required, but Org-ref will pollute your home directory otherwise, creating the cache file in ~/.orhc-bibtex-cache
  :init
  (let ((cache-dir (concat doom-cache-dir "org-ref")))
    (unless (file-exists-p cache-dir)
      (make-directory cache-dir t))
    (setq orhc-bibtex-cache-file (concat cache-dir "/orhc-bibtex-cache"))))

(use-package! doi-utils
  :after org
  :commands (crossref-add-bibtex-entry doi-utils-add-entry-from-crossref-query)
  :config
  (setq doi-utils-download-pdf nil))
#+end_src

* LaTeX mode
** AUCTeX
#+BEGIN_SRC elisp
;; Add hooks and some basic variables declations
(brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "init" t)

;; + variables has to be declared before loading module
(setq +latex-bibtex-file "~/Dropbox/bibliography/my.bib"
      +latex-viewers '(pdf-tools))

(after! latex
  ;; File types
  (add-to-list 'auto-mode-alist '("\\.sty\\'"  . LaTeX-mode))

  ;; Doom stuff
  (remove-hook 'TeX-mode-hook #'TeX-fold-mode)
  ;; Settings
  ;; Config options
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "config" t)
  ;; Add C-c C-q for clean and indent
  ;; (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "LaTeX-extra" t)
  )
#+END_SRC

** RefTeX
Add interactive TOC and references manager at .tex files.
#+begin_src elisp
(after! (latex reftex)
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "RefTeX" t)

  (add-hook! 'reftex-select-label-mode-hook
    (map! :map reftex-select-label-mode-map
          :e "j"  #'reftex-select-next
          :e "k"  #'reftex-select-previous))

  (add-hook! 'reftex-toc-mode-hook
    (map! :map 'local
          :e "1"  #'brust-reftex-toc-level-1
          :e "2"  #'brust-reftex-toc-level-2
          :e "3"  #'brust-reftex-toc-level-3
          :e "4"  #'brust-reftex-toc-level-4
          :e "5"  #'brust-reftex-toc-level-5
          :e "6"  #'brust-reftex-toc-level-6
          :e "m"  #'describe-mode
          )))
#+end_src

** CDLaTeX
#+begin_src elisp
(after! (latex cdlatex)
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "cdLaTeX" t))
#+end_src
** Bratex
    Load before auctex ??2
#+BEGIN_SRC elisp
(use-package! bratex
  :after latex)
#+END_SRC

** Bindings
#+begin_src elisp
(map! :after latex
      (:map LaTeX-mode-map
       :gin "]"    #'brust-LaTeX-insert-math1
       :gin "}"    #'brust-LaTeX-insert-math2
       ;; "C-c C-q"   #'latex/clean-fill-indent-environment ;; Now use "= G"
       "s-e"       #'brust-LaTeX-next-error
       "s-t"       #'TeX-complete-symbol ;; Auto-complete funcion of AUCTeX
       "C-c C-e"   #'brust-LaTeX-env
       "<M-up>"    #'bratex-cycle-size
       "<M-down>"  #'bratex-cycle-size-reverse
       "<M-right>" #'bratex-cycle-bracket
       "<M-left>"  #'bratex-cycle-bracket-reverse
       (:localleader
        "5" #'latex-replace-in-math
        "%" #'latex-replace-regexp-in-math
        "0" #'brust-cycle-texmath
        "W" #'brust-wc-save-words
        "r" #'reftex-reference
        "t" #'reftex-toc
        "b" #'reftex-citation
        "e" #'brust-LaTeX-set-header
        "SPC" #'TeX-command-master
        "m" #'TeX-insert-macro
        "]" #'LaTeX-close-environment
        "E" #'LaTeX-environment
        )))

(map! :after (latex cdlatex)
      :map cdlatex-mode-map
      "`" nil
      :i ";"   #'cdlatex-math-symbol
      :i "C-;" (lambda nil (insert ";"))
      :i "TAB" #'cdlatex-tab
      :localleader
      "e" #'cdlatex-environment)
#+end_src

** COMMENT LSP LaTeX
#+begin_src elisp :tangle no
;; "texlab" must be located at a directory contained in `exec-path'.
;; If you want to put "texlab" somewhere else,
;; you can specify the path to "texlab" as follows:
(setq lsp-latex-texlab-executable "~/src/texlab-git/target/release/texlab")

(after!
  (require 'lsp-latex)
  (add-hook 'tex-mode-hook 'lsp)
  (add-hook 'latex-mode-hook 'lsp))
#+end_src
* COMMENT Mu4e
** General info
    - Manual [[https://www.djcbsoftware.nl/code/mu/mu4e/index.html#Top][Mu4e's online manual]]
    - TODOs [0/6]
      - [ ] Install [[https://github.com/iqbalansari/mu4e-alert][mu4e alerts]]
      - [ ] Improve keybinding
      - [ ] Show links
      - [ ] Show images
      - [ ] Check autopudate (related to point one).
      - [ ] Improve contact completion with ivy :) [[http://pragmaticemacs.com/emacs/even-better-email-contact-completion-in-mu4e/]]
    - Helpful places [5/9]
      - [X] [[https://webgefrickel.de/blog/a-modern-mutt-setup][A modern mutt setup with neomutt, mbsync, msmtp and mu]] (blog - interesting not just emacs)
      - [ ] [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-][A Complete Guide to Email in Emacs using Mu and Mu4e]] (blog interesting by itself - really fancy emacs stuff)
      - [ ] [[https://www.djcbsoftware.nl/code/mu/mu4e/Example-configurations.html#Example-configurations][Example config (from mu4e the manual)]]
      - [ ] [[http://xenodium.com/#trying-out-mu4e-and-offlineimap][Albaro]] & [[http://xenodium.com/#trying-out-mu4e-with-mbsync][Albaro2]] (here there are many nice links) (blog - interesting not just emacs).
      - [X] [[https://stackoverflow.com/questions/50199837/mu4e-with-msmtp-does-not-store-mail-sent-directory-after-sending-mails][How to config mu4e to send mail using msmtp]]
      - [X] [[https://blog.programster.org/ubuntu-install-gpg-2][Install gpg2 (much better)]] to encript your mail password (echo password | gpg2 -c) then delete the corresponding line on bash history ;)
      - [ ] [[http://pragmaticemacs.com/mu4e-tutorials/][mu4e tutorials (form pragmatic emacs)]]
      - [X] [[https://wiki.archlinux.org/index.php/msmtp][Archlnux msmpt config page]]
      - [X] [[https://wiki.archlinux.org/index.php/Isync#Troubleshooting][Archlinux mbsync config page]]
      -
** COMMENT Install
Just in case to generate a certificate:
# openssl s_client -connect mail.mat.uab.cat:993 -showcerts 2>&1 < /dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sed -ne '1,/-END CERTIFICATE-/p' > ~/mail.uab.cat.ctr

#+BEGIN_SRC bash :tangle no
# Install things
sudo apt install msmtp-gnome msmtp-mta isync gnupg2
cd src
git clone https://github.com/djcb/mu.git
./autogen.sh
make

# Paswords
## UAB
cd
echo PASSWORD > .mathuab
gpg2 -c .mathuab
rm .mathuab
## Gmail
echo PASSWORD > .gmailpass
gpg2 -c .gmailpass
rm .gmailpass
# Delete corresponding lines of .bash_history

mkdir Maildir
# Copy from Dropbox/config/Maildir
#+END_SRC

** Add Path
#+BEGIN_SRC elisp :tangle no
(add-to-list 'load-path (expand-file-name "~/src/mu/mu4e/"))
#+END_SRC

** Config
[[file:lisp/brusts-mu4e-config.org][Mu4e config file]]
#+begin_src elisp :tangle no
(use-package! mu4e
  :commands (mu4e)
  :config
  ;; The setq's
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Basic" t)

  ;; My contexts
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Contexts" t)

  ;; Actions
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Actions" t)

  ;; My Main menu
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Main Menu" t)

  ;; Marking emails for new actions
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Marks" t)
  (map! (:map mu4e-headers-mode-map
         "g" #'mu4e-headers-mark-for-tag
         "A" #'mu4e-headers-mark-for-moveUAB)
        (:map mu4e-view-mode-map
         "g" #'mu4e-headers-mark-for-tag
         "A" #'mu4e-headers-mark-for-moveUAB))

  ;; Fixing 'evil-collection-mu4e', see update in https://github.com/emacs-evil/evil-collection/issues/309
  (defun brust-workaround-fixing-evil-collection-mu4e nil
    (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view))
  (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view)
  (advice-add 'evil-collection-mu4e-setup :after #'brust-workaround-fixing-evil-collection-mu4e)

  (map! :map mu4e-headers-mode-map
        ;; "." #'hydra-mu4e-headers/body ; This hydra is for headers mode
        "o" #'my/org-capture-mu4e                 ; differs from built-in
        "A" #'mu4e-headers-mark-for-action        ; differs from built-in
        "|" #'mu4e-view-pipe                         ; does not seem to be built in any longer
        ))
#+end_src

* Programming
** Julia mode
*** TODO Intro [update]
julia-mode is just for editing .jl files (every other julia related mode uses it for this propose).

ESS julia provides ESS[julia] mode to edit .jl files, which uses julia-mode for syntaxis.
It also provides an interaction with Julia REPL, but with limited functionality:
Starts a julia process whose output is print in a buffer, but the buffer is not a terminal.
Problems:
  - Polymake does not load (I do not know the reason)
  - It has no colors
  - The functionalities ; ] of julia does not work and ? works but prompt does not changes.
    see[[https://github.com/emacs-ess/ESS/issues/143][Terminal not fully functional]]
Good things
  - It creates a backend for company (it requires to start the julia process)
  - The backend (sometimes?) even incorporates user defined variables!
  - Full integration with Doom emacs (eval region/line... under localleader key)

julia-repl is another way to communicate with julia.
It creates a julia process running in a term terminal in Emacs.
Good
  - Polymake load
  - has colors
  - has the functionalities ; ] ? and the prompt changes.
Bad
  - zero integration with company
  - zero integration with Doom emacs
    see [[https://github.com/tpapp/julia-repl/issues/81][problem with executable]]

*** Julia repl mode
#+begin_src elisp
;; (setq auto-mode-alist (delete '("\\.jl\\'" . ess-julia-mode) auto-mode-alist))

;; `ob-julia' needs this variable to be defined, but it's defined in
;; `ess-custom', which won't be available if you're using :lang julia and not
;; :lang ess.
(defvar inferior-julia-program-name (or (executable-find "julia") "julia"))

(after! julia-repl
  (julia-repl-set-terminal-backend 'vterm)
  ;; (add-hook 'term-mode-hook #'visual-line-mode)
  ;; (setq auto-mode-alist (delete '("\\.jl\\'" . ess-julia-mode) auto-mode-alist))
  ;; treat underscores as word delimiters, see https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-do-i-get-motions-to-treat-underscores-as-word-delimiters
  (add-hook! 'julia-mode-hook (modify-syntax-entry ?_ "w"))
  (when (executable-find "julia")
    (setq julia-repl-executable-records
          `(;; (default "julia")
            (master ,(executable-find "julia")))))

  ;; (add-hook! 'julia-repl-hook (julia-repl--send-string (concat "include(\"" (expand-file-name "~/.julia/config/startup.jl") "\")")))
  ;; It cause a problem, execute julia-repl--send-string in this hook (outside hook there is no problem, not realted to doom, emacs -q and install julia-repl reproduce it) Actually, not needed, now julia-repl loads startup.jl
  (map! (:map julia-mode-map
         (:localleader
          :desc "Generate exports"    "x" #'brust-julia-update-exports))
        (:map julia-repl-mode-map
         (:localleader
          :desc "line or region"      "SPC" #'julia-repl-send-region-or-line
          :desc "Start process"       "o" #'+julia/open-repl
          :desc "Start eglot server"  "." #'+lsp!
          :desc "Set dir to buffer's" "d" #'julia-repl-cd
          :desc "Doc symbol"          "h" #'julia-repl-doc
          :desc "Call \\@edit"        "e" #'julia-repl-edit
          :desc "Send buffer"         "b" #'julia-repl-send-buffer
          :desc "Methods symbol"      "m" #'julia-repl-list-methods))
        (:map vterm-mode-map
         :prefix "C-c"
         :desc "Clear buffer" "d" #'comint-clear-buffer)))
#+end_src

*** COMMENT eglot-jl
#+begin_src elisp :tangle no
(after! eglot
  ;; (defun brust-lsp-ask-before-activating nil
  ;;   (let ((buffer (current-buffer)))
  ;;     (if (y-or-n-p (format "Activate LSP server for buffer %s " buffer))
  ;;         t
  ;;       (message "LSP server not activated.")
  ;;       nil)))
  ;; (advice-add 'lsp! :before-while #'brust-lsp-ask-before-activating)

  (setq eglot-connect-timeout (* 60 2)
        lsp-julia-default-environment "~/.julia/environments/v1.7"
        eglot-jl-julia-command "~/src/julia/bin/julia"
        ;; Activate LSP server when I want to
        julia-mode-local-vars-hook nil ;; To use my LanguageServer and Symbols...
        ;; eglot-jl-language-server-project "~/.julia/environments/v1.6"
        ;; To use eglot's LanguageServer and Symbols... (ther is no way to make it work)
        eglot-jl-language-server-project eglot-jl-base
        ))
#+end_src
*** LSP mode

Run =doom build= to make it work (no idea why...)

#+begin_src elisp
(use-package! lsp-julia
  :after lsp
  :config
  (setq lsp-julia-package-dir nil
        ;; lsp-julia-default-environment "~/.julia/environments/v1.7"
        ;; lsp-enable-folding t
        lsp-julia-lint-nothingcomp nil ;; Do not check for nothing === something
        lsp-julia-format-indents nil
        lsp-julia-format-calls t
        ))
#+end_src

*** ad-hoc functions
**** Launch or link a julia process in vterm buffer

#+begin_src elisp
(defun brust-julia--launch-and-link-vterm nil
  (brust-vterm--launch-and-link (buffer-name) "--vjulia")
  (brust-vterm--eval-string "julia\n"))

(defun brust-julia--link-or-launch-and-link-vterm nil
  (interactive)
  (if (y-or-n-p "Link buffer to a julia process [y] or launch and link a new one [n]")
      (brust-vterm--link
       (save-window-excursion
         (consult-buffer)
         (buffer-name))
       (buffer-name))
    (brust-julia--launch-and-link-vterm)))
#+end_src

**** Ensure a running julia process is linked
#+begin_src elisp
(defun brust-julia--ensure-vterm-process-alive nil
  ;; When process is not alive, always launch a new one without asking.
  ;; If I wanted to link (unlikely), I can kill the new process and
  ;; call brust-..-link-or-launch-and-link.
  (unless (process-live-p vterm--process) (brust-julia--launch-and-link-vterm)))
#+end_src

**** Input manipulation
#+begin_src elisp
(defun brust--julia-input-bounds nil
  (save-excursion
    (move-beginning-of-line 1)
    (search-forward "> " (point-at-eol) t)
    ;; (message "  Input bounds are %i %i"
    ;;          (car (cons (point) (point-at-eol)))
    ;;          (cdr (cons (point) (point-at-eol))))
    (cons (point) (point-at-eol))))

(defun brust--julia-input-string nil
  (let* ((-bounds (brust--julia-input-bounds))
         (-str (buffer-substring (car -bounds) (cdr -bounds))))
    ;; (message "  Input string is \"%s\"" -str)
    -str))

(defun brust--julia-input-delete nil
  (interactive)
  (let* ((-bounds (brust--julia-input-bounds))
         (N (- (cdr -bounds) (car -bounds))))
    (dotimes (i N) (term-send-left))
    (dotimes (i N) (term-send-del))))
#+end_src

**** Send common functions

#+begin_src elisp
(defun brust-julia--add-function (-fun)
  ;; (move-end-of-line 1)
  ;; (dotimes (i (point-at-eol) (point)) (term-send-right))
  (let ((input (brust--julia-input-string)))
    (brust--julia-input-delete)
    (julia-repl--send-string (concat -fun "(" input ")"))))

(defvar brust-julia-add-function-alist
  '("typeof"
    "eltype"
    "size")
  "\
List if julia functions names to define wrap for.")

(after! vterm
  (cl-loop for fun in brust-julia-add-function-alist do
           ;; (message "dir %s, name %s" (car dirname) (cdr dirname))
           (let ((fun-name (intern (format "brust-julia-send-%s" fun)))
                 (desc (concat "Sent wrap for " fun))
                 (bind (downcase (substring fun 0 1))))
             ;; (message "dir %s, name %s" dir name)
             (fset fun-name
                   `(lambda nil (interactive)
                      (brust-julia--add-function ,fun)))
             (map! (:map vterm-mode-map
                    (:prefix "C-c"
                     (:prefix ("f" . "Wrap fun")
                      :desc desc bind fun-name)))))))
#+end_src

**** Generate 'exports'
#+begin_src elisp
(defun brust-julia-update-exports nil
  (interactive)
  (save-excursion
    (let ((defunlist (brust-julia--collect-defuns)))
      (goto-char (point-min))
      (insert "\nexport\n")
      (while (< 1 (length defunlist))
        (insert (car (pop defunlist)) ",\n"))
      (insert (car (pop defunlist)) "\n"))))

(defun brust-julia--collect-defuns nil
  (goto-char (point-max))
  (let ((defunlist '()))
    (while (julia-beginning-of-defun)
      (if (string= (thing-at-point 'word t) "function") (forward-word 2))
      (pushnew! defunlist (julia-repl--symbols-at-point))
      (move-beginning-of-line 1))
    defunlist))
#+end_src

** Maple
#+begin_src elisp
;; (add-load-path! "~/src/maplev-master/lisp")
(autoload 'maplev-mode "maplev" "Maple editing mode" 'interactive)
(add-to-list 'auto-mode-alist '("\\.mpl\\'" . maplev-mode))
#+end_src

** POV-Ray
#+begin_src elisp
(defun brust-pov-ray-compile nil
  (interactive)
  (save-buffer)
  (pov-menu-render-highest))

(map! :localleader
      :map pov-mode-map
      "SPC" #'brust-pov-ray-compile
      "q" #'pov-command-query ;AS
      "h" #'pov-keyword-help
      "r" #'pov-tool-bar-command-render
      "l" #'pov-show-render-output
      "1" #'pov-menu-render-test
      "2" #'pov-menu-render-low
      "3" #'pov-menu-render-mid
      "4" #'pov-menu-render-high
      "5" #'pov-menu-render-highest
      "i" #'pov-open-include-file
      "e" #'pov-menu-external-viewer
      "v" #'pov-menu-internal-viewer
      )
#+end_src

** TODO Singular
*** Config
#+BEGIN_SRC elisp
(setq singular-emacs-home-directory "/usr/share/singular/emacs/")
;; (add-load-path! singular-emacs-home-directory)
(cl-pushnew singular-emacs-home-directory load-path :test #'string=)
(autoload 'singular "singular"
  "Start Singular using default values." t)
(autoload 'singular-other "singular"
  "Ask for arguments and start Singular." t)

(add-to-list 'auto-mode-alist '("\\.sing\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.lib\\'" .  c++-mode))

(defun brust-singular-mode-hook nil
  ;; turn-on fontification for c++-mode
  (font-lock-mode 1)
  (set (make-local-variable 'singular-commands-alist) nil)
  (load (concat singular-emacs-home-directory "cmd-cmpl"))
  ;; turn on aut-new line
  (c-toggle-auto-newline 1)
  ;; tunr off hungry-delete
  (c-toggle-hungry-state -1)
  (company-mode -1))

(add-hook 'c++-mode-hook #'brust-singular-mode-hook)

(defun brust-singular-intetractive-mode nil
  (brust-math-software-hookfun-to-intangify-prompt)
  (hl-line-mode 1))

(add-hook 'singular-interactive-mode-hook #'brust-singular-intetractive-mode)

(defadvice singular-send-or-copy-input (before finish-line activate)
  (brust-singular-finish-line-interaction-mode))

#+END_SRC

*** Maps
#+begin_src elisp
(map! (:map c++-mode-map
       "C-<return>" #'newline
       "<return>" #'brust-singular-finish-line-singular-edit-mode
       (:localleader
        "<tab>" #'brust-singular-dynamic-complete
        "a"   #'singular-beginning-of-line
        "p"   #'brust-singular-add-print
        "s"   #'brust-singular-add-std
        "SPC" #'brust-singular-eval-region-or-line
        ";" #'comment-region
        "b" #'brust-singular-eval-buffer
        "s" #'brust-singular-fixed-region-set-region
        "f" #'brust-singular-fixed-region-eval
        "e" #'brust-singular-eval-proc))
      (:map singular-interactive-mode-map
       "C-p" #'brust-singular-add-print
       "C-s" #'brust-singular-add-std))
#+end_src

*** function to send the working file.
#+BEGIN_SRC elisp

(defvar brust-singular-fixed-region-poss nil "Cons of positions delimiting the fixed region")

(defun brust-singular-fixed-region-set-region (args)
  (interactive "P")
  (unless (use-region-p) (user-error "Region has to be activate"))
  (let ((beg (region-beginning))
        (end (region-end)))
    (setq brust-singular-fixed-region-poss (cons beg end))
    (message "Fixed-region seted from line %d to %d"
             (line-number-at-pos beg)
             (line-number-at-pos end)))
  (deactivate-mark t))

(defun brust-singular-fixed-region-eval (args)
  (interactive "P")
  (message "Evaluated region (%d:%d) in [[%s]]"
           (line-number-at-pos (car brust-singular-fixed-region-poss))
           (line-number-at-pos (cdr brust-singular-fixed-region-poss))
           buffer-file-name)
  (brust-singular--eval-string
   (buffer-substring-no-properties
    (car brust-singular-fixed-region-poss)
    (cdr brust-singular-fixed-region-poss))
   args))

(defun brust-singular-eval-region-or-line (args)
  (interactive "P")
  (let (-str)
    (if (not (use-region-p))
        (save-excursion
          (while (not (or (brust-singular--ending-semicolon-p) (bobp)))
            (forward-line -1))
          (setq -str (thing-at-point 'line t))
          (unless (brust-singular--ending-semicolon-p -str)
            (user-error "There is no line to eval"))
          (unless (brust-singular--check-parents -str)
            (user-error "Unbalanced Parents!!!"))
          (message "Evaluated line (%d) in [[ %s ]]"
                   (line-number-at-pos (point))
                   (buffer-name)))
      (message "Evaluated region between lines (%d:%d) in [[ %s ]]"
               (line-number-at-pos (region-beginning))
               (line-number-at-pos (region-end))
               (buffer-name))
      (setq -str (buffer-substring-no-properties
                  (region-beginning) (region-end))))
    (brust-singular--eval-string -str args)))

(defun brust-singular--ending-semicolon-p (&optional -string)
  (unless -string
    (setq -string (thing-at-point 'line t)))
  (string= ";"
           (substring (s-trim
                       (car
                        (split-string
                         -string "//")))
                      -1)))

(defun brust-singular--check-parents (&optional -string)
  (unless -string
    (setq -string (thing-at-point 'line t)))
  (with-temp-buffer
    (insert -string)
    (ignore-errors (check-parens) t)))

(defun brust-singular--eval-string (-str &optional args)
  (save-window-excursion
    (singular)
    (goto-char (point-max))
    (let ((process (singular-process))
          (--str (concat (s-trim -str)
                         (unless (string= (substring -str -1) ";")
                           "\n;"))))
      (when args (singular-control-c 'restart))
      (singular-input-filter process --str)
      (singular-send-string process --str))))

(defun brust-singular--delete-comments (&optional -string)
  (unless -string
    (setq -string (thing-at-point 'line t)))
  (with-temp-buffer
    (insert -string)
    (goto-char (point-min))
    (while (search-forward "//" nil t)
      (forward-char -2)
      (delete-region (point) (line-end-position)))
    (buffer-string)))

(defun brust-singular-eval-proc (args)
  "Eval last proc declaration."
  (interactive "P")
  (save-excursion
    (search-backward "proc" nil t)
    (let ((-beg (point))
          (-name
           (if (re-search-forward "[ \s\t]+" (line-end-position) t)
               (let ((-beg2 (point)))
                 (if (search-forward "(" (line-end-position) t)
                     (s-trim (buffer-substring-no-properties -beg2 (1- (point))))
                   nil))
             nil)))
      (search-forward "{" nil t)
      (forward-char -1)
      (sp-forward-sexp)
      (brust-singular--eval-string
       (buffer-substring-no-properties -beg (point))
       args)
      (if -name
          (message "Evaluated proc {{%s}}, between lines (%d:%d), in file [[%s]]"
                   -name
                   (line-number-at-pos -beg)
                   (line-number-at-pos (point))
                   (file-name-base (buffer-name)))
        (message "Evaluated proc between lines (%d:%d) and file [[%s]] (Warring:: its name is not on the definition line)"
                 (line-number-at-pos -beg)
                 (line-number-at-pos (point))
                 (file-name-base (buffer-name)))))))

;;(defun brust-singular-eval-buffer-line-by-line nil
;;  (interactive)
;;  (let ((-total-str (buffer-string))
;;        (-base-name (file-name-base (buffer-name))))
;;    (with-temp-buffer
;;      (insert -total-str)
;;      (brust-singular--delete-comments)
;;      (goto-char (point-min))
;;      (while (not (eobp))
;;        ;;(or (brust-check-line-parents) (user-error "Unbalanced Parent!!!"))
;;        (let ((-str (s-trim (buffer-substring-no-properties
;;                             (line-beginning-position)
;;                             (line-end-position))))
;;              (-line (line-number-at-pos)))
;;          (unless
;;              (cond ((string= -str "") t)
;;                    ((string= (substring -str -1) ";")
;;                     (brust-singular--eval-string
;;                      -str
;;                      (format "line:%d:of::%s--" -line -base-name)
;;                      nil)
;;                     t)
;;                    (t (brust-singular-eval-environment args) t))
;;            (message "Error on line:%d (%s)" -line -str)
;;            (goto-char (point-max)))
;;          ;;(when err (goto-char err))
;;          (forward-line 1))))))

;;(defun brust-singular--temp-file (-str -name)
;;  (let ((-temp-file
;;         (make-temp-file
;;          (replace-regexp-in-string "[.]" "-" -name)
;;          nil ".sing")))
;;    (with-temp-buffer
;;      (insert -str)
;;      (append-to-file (point-min) (point-max) -temp-file))
;;    -temp-file))
#+END_SRC

*** functions for *singular*
**** Add print std...
#+BEGIN_SRC elisp
(defun brust-singular-add-print nil
  (interactive)
  (brust-singular-add-function "print"))

(defun brust-singular-add-std nil
  (interactive)
  (brust-singular-add-function "std"))

(defun brust-singular-add-function (-fun)
  (let* ((-bounds (if (region-active-p)
                      `(,(region-beginning) . ,(region-end))
                    (save-excursion
                      (move-beginning-of-line 1)
                      (search-forward "> " (point-at-eol) t)
                      `(,(point) . ,(progn
                                      (move-end-of-line 1)
                                      (search-backward ";" (point-at-bol) t)
                                      (point))))))
         (-str (buffer-substring-no-properties (car -bounds) (cdr -bounds))))
    (goto-char (car -bounds))
    (delete-region (car -bounds) (cdr -bounds))
    (insert -fun "(" -str ")")
    (move-end-of-line 1)
    (insert ";")))
#+END_SRC

**** Finish line
#+BEGIN_SRC elisp
(defun brust-singular-finish-line-singular-edit-mode nil
  (interactive)
  (if (or (bolp) (eobp)) (insert "\n")
    (move-end-of-line 1)
    (when (search-backward "//" (point-at-bol) t)
      (skip-chars-backward "[:space:]"))
    (let ((-main-line (s-trim-right
                       (buffer-substring-no-properties (point-at-bol) (point))))
          (-comment-line (buffer-substring-no-properties (point) (point-at-eol))))
      (delete-region (point-at-bol) (point-at-eol))
      (if (or (< (length -main-line) 1))
          (insert (concat -comment-line "\n"))
        (insert
         (concat ;;compare (insert (concat nil "hello")) vs (insert nil "hello")
          (with-temp-buffer ;; To close-all-open-paren-r just of this line and do not use narrow
            (insert (concat -main-line
                            (unless (string= (substring -main-line -1) ";")
                              ";")))
            (forward-char -1)
            (close-all-open-paren-right)
            (buffer-string))
          -comment-line
          "\n"))))))

(defun brust-singular-finish-line-interaction-mode nil
  (interactive)
  (narrow-to-region (point-at-bol) (point-at-eol))
  (move-end-of-line 1)
  (delete-horizontal-space)
  (unless (string= (string (char-before (point))) ";")
    (insert ";"))
  (forward-char -1)
  (close-all-open-paren-right)
  (widen))

#+END_SRC

**** Dynamic expand in non-running Singular buffer
#+BEGIN_SRC elisp
(defun brust-singular-dynamic-complete ()
  "Dynamic complete word before point.
      Performs completion of Singular commands."
  (interactive)
  (let* ((end (point))
         (beg
          (save-excursion
            (skip-chars-backward "a-zA-Z0-9")
            (point)))
         (str (buffer-substring-no-properties beg end)))
    (if (string= str "")
        (indent-region (point-at-bol) (point-at-eol))
      ;; (call-interactively 'indent-region)
      (if singular-commands-alist
          (singular-completion-do str beg end singular-commands-alist)
        (message "Completion of Singular commands disabled.")
        (ding)))))
#+END_SRC

** Macaulay2 M2
*** Config.
#+begin_src elisp
;; Setup M2.el for autoloading
;; add "/usr/share/info" to Info-default-directory-list if it isn't there (it is already there)
;; (add-to-list 'Info-default-directory-list "/usr/share/info")
;; (add-load-path! "/usr/share/emacs/site-lisp/Macaulay2/")
(cl-pushnew  "/usr/share/emacs/site-lisp/Macaulay2/" load-path :test #'string=)

(autoload 'M2             "M2" "Run Macaulay2 in an emacs buffer" t)
(autoload 'M2-mode        "M2" "Macaulay2 editing mode" t)
(autoload 'm2-mode        "M2" "Macaulay2 editing mode, name in lower case" t)
(autoload 'm2-comint-mode "M2" "Macaulay2 command interpreter mode, name in lower case" t)
(add-to-list 'auto-mode-alist '("\\.m2\\'" . M2-mode))

;; Uncomment these lines to enable syntax highlighting for the interpreter language
;;(autoload 'D-mode "D-mode" "Editing mode for the interpreter language" t)
;;(add-to-list 'auto-mode-alist '("\\.dd?\\'" . D-mode))
#+end_src

*** Map
#+begin_src elisp
(map! (:map M2-mode-map
       :n "= Q" #'brust-M2-indent-buffer
       (:localleader
        "SPC" #'brust-M2-M2-or-M2-send-to-program
        "Q" #'brust-M2-indent-buffer)))
#+end_src

*** Indent buffer
#+begin_src elisp
(defun brust-M2-electric-tab-inerit-indentation nil
  (let ((context (delete-white-space)))
    (M2-electric-tab)
    (when (string-match-p "\n" context) (insert context))))

(defun brust-M2-indent-buffer nil
  (interactive)
  (brust-apply-function-line-by-line 'brust-M2-electric-tab-inerit-indentation))
#+end_src
*** M2 or send line
#+begin_src elisp
(defun brust-M2-M2-or-M2-send-to-program nil
  (interactive)
  (if (get-buffer "*M2*")
      (call-interactively 'M2-send-to-program)
    (call-interactively 'M2)))
#+end_src

* Build-in modes
** Abbrev's
*** Setting
#+BEGIN_SRC elisp
(setq pre-abbrev-expand-hook (quote (ignore))
      save-abbrevs 'silently)
(when (file-exists-p "~/Dropbox/config/abbrev-def.el")
  (setq abbrev-file-name "~/Dropbox/config/abbrev-def.el"))

(setq-default abbrev-mode t)
(add-hook 'emacs-startup-hook #'quietly-read-abbrev-file)
#+END_SRC

*** COMMENT Endless ispell & abbrev
     It comes from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Ispell and abbrev]], to find the misspelled work plain =ispell= is used, I adapted it to use =flyspell=, now I just get words which are underlined as misspelled (red curvi line under the word).
     That's useful in TeX files where plain ispell has many false misspellings, but it could be a problem on buffers without =flyspell= minormode.
#+BEGIN_SRC elisp :tangle no
(defun endless/simple-get-word ()
  (car-safe (save-excursion (ispell-get-word nil))))

(defun endless/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev. Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer. You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
  (interactive "P")

  (let ((top (window-start))
        (bot (window-end))
        (position (point))
        incorrect-word-pos
        position-at-incorrect-word
        bef aft)
    (save-excursion
      (save-restriction
        ;; make sure that word under point is checked first
        (forward-word)

        ;; narrow the region
        (narrow-to-region top bot)
        (overlay-recenter (point))

        (let ((overlay-list (overlays-in (point-min) (+ position 1)))
              (overlay 'dummy-value))

          (while overlay
            (setq overlay (car-safe overlay-list))
            (setq overlay-list (cdr-safe overlay-list))
            (when (and overlay
                       (flyspell-overlay-p overlay))
              (setq incorrect-word-pos (overlay-start overlay))

              ;; try to correct word
              (save-excursion
                (goto-char incorrect-word-pos)
                (setq bef (endless/simple-get-word))
                ;; `flyspell-correct-at-point' returns t when there is
                ;; nothing to correct. In such case we just skip current word.
                (unless (flyspell-correct-at-point)
                  (setq overlay nil)
                  (setq aft (endless/simple-get-word)))))))))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))
#+END_SRC

** Auto revert
    I need this to work with Git and branching.
    Auto refresh all buffers when files have changed on disk.
#+BEGIN_SRC elisp
(setq global-auto-revert-ignore-modes (quote (PDFView))
      auto-revert-check-vc-info t)

(add-hook! 'emacs-startup-hook (global-auto-revert-mode +1))
#+END_SRC

** Ediff
   The default Ediff behavior is confusing and not desirable. This fixes it.
#+BEGIN_SRC elisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC

   Make it compatible with =org-mode=
#+BEGIN_SRC elisp
(defun ora-ediff-prepare-buffer nil
  (when (memq major-mode '(org-mode emacs-lisp-mode))
    (outline-show-all)))
#+END_SRC

#+BEGIN_SRC elisp
(defun ediff-copy-both-to-C nil
  (interactive)
  (ediff-copy-diff
   ediff-current-difference nil 'C nil
   (concat
    (ediff-get-region-contents
     ediff-current-difference 'A ediff-control-buffer)
    (ediff-get-region-contents
     ediff-current-difference 'B ediff-control-buffer))))

(defun add-d-to-ediff-mode-map nil
  (define-key ediff-mode-map "d" #'ediff-copy-both-to-C))
#+END_SRC

#+begin_src elisp
(after! ediff
  (add-hook 'ediff-keymap-setup-hook #'add-d-to-ediff-mode-map)
  (add-hook 'ediff-prepare-buffer-hook 'ora-ediff-prepare-buffer))
#+end_src
** Eldoc
#+begin_src elisp
(setq eldoc-echo-area-use-multiline-p nil)
#+end_src
** High light TODO
Package to highlight TODO's in comments and so.
#+begin_src elisp
(setq hl-todo-highlight-punctuation ":")
#+end_src
** Ispell

#+begin_src elisp
(setq ispell-highlight-face 'flyspell-incorrect)
#+end_src

** Tramp
#+begin_src elisp
(setq password-cache-expiry nil
      remote-file-name-inhibit-cache nil
      tramp-completion-reread-directory-timeout nil
      auth-source-cache-expiry nil
      tramp-ssh-controlmaster-options "" ;; See https://www.reddit.com/r/emacs/comments/fgl6gu/emacs_tramp_tricks/ and https://puppet.com/blog/speed-up-ssh-by-reusing-connections/
      tramp-verbose 1
      vc-ignore-dir-regexp
      (format "\\(%s\\)\\|\\(%s\\)"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))

(defun brust-decrypt (file)
  (when (file-exists-p file)
    (let ((-temp-file (make-temp-file (file-name-base file))))
      (epa-decrypt-file file -temp-file)
      (delete-file -temp-file))))

;; (add-hook! 'emacs-startup-hook (brust-decrypt "~/.authinfo.gpg"))
#+end_src

* External modes
** Avy
#+begin_src elisp
(setq avy-flyspell-correct-function #'+spell/correct)
#+end_src

** Ibuffer
- [[http://martinowen.net/blog/2010/02/03/tips-for-emacs-ibuffer.html][Blog nice config]]

#+begin_src elisp
(after! ibuffer
  ;; ReRedefine size column to display human readable number of line,
  ;; a humanly understandable measure of size.
  (define-ibuffer-column size
    (:name "nºLines"
     :inline t
     :header-mouse-map ibuffer-size-header-map)
    (let ((n (line-number-at-pos (point-max))))
      (cond
       ((> n 1000000) (format "%7.1fM" (/ n 1000000.0)))
       ((> n 1000) (format "%7.1fk" (/ n 1000.0)))
       ;;((> n 100) (format "%7.1fh" (/ n 100.0)))
       (t (format "%8d" n)))))

  ;; (setq ibuffer-formats
  ;;       ;; Modify the default ibuffer-formats (toggle with `)
  ;;       '((mark modified read-only vc-status-mini " "
  ;;               (name 30 30 :left :elide)
  ;;               " "
  ;;               (size 9 -1 :right)
  ;;               " "
  ;;               (mode 16 16 :left :elide)
  ;;               " "
  ;;               (vc-status 16 16 :left)
  ;;               " "
  ;;               filename-and-process)
  ;;         (mark " " (name 16 -1) " " filename)))

  (setq ibuffer-saved-filter-groups
        (list (cons "home"
                    `((,(concat
                         (all-the-icons-icon-for-mode 'org-mode :v-adjust -0.05)
                         " Org")
                       (or (mode . org-mode)
                           (name . "Org")
                           (filename . "Org")))
                      (,(concat
                         (all-the-icons-octicon
                          "file-directory"
                          :face ibuffer-filter-group-name-face
                          :v-adjust -0.05)
                         " Files") (filename . ".*"))
                      (,(concat
                         (all-the-icons-icon-for-mode 'dired-mode :v-adjust -0.05)
                         " Dired")
                       (mode . dired-mode))
                      (,(concat
                         (all-the-icons-icon-for-mode 'vterm-mode :v-adjust -0.05)
                         " Vterm")
                       (mode . vterm-mode))
                      ("Magit" (name . "\*magit"))
                      ("ERC" (mode . erc-mode))
                      ("Help" (or (name . "\*Help\*")
                                  (name . "\*Apropos\*")
                                  (filename . ".el.gz$")
                                  (name . "\*info\*")))
                      ("Doom emacs" (or
                                     (name . "^\\*scratch\\*$")
                                     (name . "^\\*doom\\*$")
                                     (name . "^\\*Messages\\*$")))
                      ("System" (name . "^\*.*\*$"))
                      )))
        ibuffer-sorting-mode 'alphabetic
        ibuffer-expert t
        ibuffer-hook nil)

  (add-hook 'ibuffer-hook 'brust-ibuffer-setting)

  (defun brust-ibuffer-setting nil
    (setq ibuffer-filter-groups (append
                                 (ibuffer-projectile-generate-filter-groups)
                                 (cdr (assoc "home" ibuffer-saved-filter-groups)))
          ibuffer-hidden-filter-groups nil)
    (ibuffer-update nil t))
  )
#+end_src

** Company
#+BEGIN_SRC elisp
(map! :after company
      :map company-active-map
      "TAB"    #'brust-company-abort-cdlatex-or-yas
      "<tab>"  #'brust-company-abort-cdlatex-or-yas
      ;; "M-o"    #'counsel-company
      "<left>" #'company-complete-common
      "<right>" #'brust-company-insert-selection
      "C-j"    #'company-next-page
      "C-k"    #'company-previous-page
      "C-l"    #'company-show-location
      )

(defun brust-company-abort-cdlatex-or-yas nil
  (interactive)
  (company-abort)
  (cond ((fboundp 'cdlatex-tab) (cdlatex-tab))
        ((fboundp 'yas-expand) (yas-expand))))

(defun brust-company-insert-selection nil
  "Insert the selected candidate and continue company."
  (interactive)
  (when (and (company-manual-begin) company-selection)
    (let ((result (nth company-selection company-candidates)))
      (company--insert-candidate result))))
#+END_SRC

** Evil mode
*** Settings
#+BEGIN_SRC elisp
(setq evil-cross-lines t
      ;; Use both =jk= and =kj= to esc insert mode
      ;; (equivalent to key-chords jk kj) Press them as single key!
      evil-escape-unordered-key-sequence t
      evil-split-window-below t
      ;; pasting in visual state NOT adds the replaced text to the kill ring
      evil-kill-on-visual-paste nil
      ;; cursor is allowed to move one character past the end of the line
      evil-move-beyond-eol t
      evil-vsplit-window-right t)
(global-evil-visualstar-mode +1)
#+END_SRC

*** Del char
Do not add single deleted chars to =kill-ring=
[[https://github.com/syl20bnr/spacemacs/issues/6977]]

#+begin_src elisp
(defun bb/evil-delete--black-hole-register (orig-fn beg end &optional type _ &rest args)
  (apply orig-fn beg end type ?_ args))

(advice-add 'evil-delete-char :around 'bb/evil-delete--black-hole-register)
(advice-add 'evil-delete-backward-char :around 'bb/evil-delete--black-hole-register)
#+end_src

** COMMENT Formater
I just want auto format in a few modes.
#+begin_src elisp :tangle no
(add-hook 'julia-mode-hook #'format-all-mode)
(add-hook 'emacs-lisp-mode-hook #'format-all-mode)

;; (setq +format-on-save-enabled-modes
;;       '(not emacs-lisp-mode  ; elisp's mechanisms are good enough
;;             sql-mode         ; sqlformat is currently broken
;;             tex-mode         ; latexindent is broken
;;             c-mode
;;             latex-mode))
#+end_src

** Key-frequency
#+BEGIN_SRC elisp
(use-package! keyfreq
  :init
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
  (setq keyfreq-excluded-commands
        '(self-insert-command
          forward-char
          backward-char
          previous-line
          next-line)))
#+END_SRC

** LSP mode
[[https://github.com/emacs-lsp/lsp-mode/blob/2d41848dde2fdcb1a85546302c4b842a12a68ef9/docs/tutorials/how-to-turn-off.md][How to turn off futures]]
*** LSP ui

This package contains all the higher level UI modules of =lsp-mode=, like =flycheck= support and code lenses.

#+begin_src elisp
(use-package! lsp-ui
  :after lsp
  :hook (lsp-mode . lsp-ui-mode)
  :config
  (setq lsp-ui-sideline-enable t)
  (setq lsp-ui-sideline-show-hover nil)
  (setq lsp-ui-doc-position 'bottom)
  (lsp-ui-doc-show))
#+end_src
*** LSP treemacs

#+begin_src elisp
(use-package! lsp-treemacs
  :after lsp
  :commands lsp-treemacs-errors-list)
#+end_src

** Magit
    For a git and github integration with emacs!
#+BEGIN_SRC elisp
(after! magit
  (setq magit-turn-on-auto-revert-mode nil
        magit-diff-hide-trailing-cr-characters t
        magit-set-upstream-on-push 'dontask
        magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1
        magit-save-repository-buffers 'dontask
        magit-diff-paint-whitespace t
        magit-diff-refine-ignore-whitespace nil
        magit-diff-refine-hunk t)

  (add-hook 'magit-log-edit-mode-hook #'turn-on-flyspell)
  (add-hook 'git-commit-mode-hook #'turn-on-flyspell))
#+END_SRC

** Nyan
    Show the rainbow progres line.
#+BEGIN_SRC elisp
(use-package! nyan-mode
  :defer t
  :init
  (add-hook! 'emacs-startup-hook (nyan-mode +1))
  :config
  (setq nyan-minimum-window-width 90
        ;;nyan-cat-face-number 3
        +nyan-outerspace-image+ "~/.doom.d/local/outerspace.xpm"
        nyan-wavy-trail nil
        nyan-animate-nyancat nil
        ;; nyan-animation-frame-interval 0.2
        nyan-bar-length 36)
  ;; (nyan-start-animation)
  )

(use-package! zone
  :after nyan-mode
  :config
  (zone-when-idle (* 5 60)))

(use-package! zone-nyan
  :after zone
  :config
  (setq zone-programs [zone-nyan]
        zone-nyan-hide-progress t))
#+END_SRC

** Pdf tools
#+BEGIN_SRC elisp
(after! pdf-tools
  ;; open pdfs scaled to fit page
  ;; (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t
        pdf-view-resize-factor 1.1)
  ;; faster motion
  (map!
   :map pdf-view-mode-map
   :n "<"            #'pdf-view-first-page
   :n ">"            #'pdf-view-last-page
   :n "q"            #'kill-current-buffer
   ;; "C-k"          #'pdf-view-next-page-command
   ;; "C-i"          #'pdf-view-previous-page-command
   ;; "s-SPC"        #'pdf-view-scroll-down-or-previous-page
   :n "s-j"          #'pdf-view-next-line-or-next-page
   :n "s-k"          #'pdf-view-previous-line-or-previous-page
   :n "s-h"          #'image-backward-hscroll
   :n "s-l"          #'image-forward-hscroll
   :n "j"            #'brust-pdf-view-next-line-or-next-page-5
   :n "k"            #'brust-pdf-view-previous-line-or-previous-page-5
   :n "h"            #'brust-image-backward-hsroll-5
   :n "l"            #'brust-image-forward-hsroll-5
   ;; "C-n"          #'brust-ace-window
   ;; "n"            #'brust-ace-window
   :n "<mouse-5>"    #'brust-pdf-view-next-line-or-next-page-5
   :n "<mouse-4>"    #'brust-pdf-view-previous-line-or-previous-page-5
   :n "C-<mouse-5>"  #'pdf-view-next-page-command
   :n "C-<mouse-4>"  #'pdf-view-previous-page-command
   :n "s-<mouse-5>"  #'pdf-view-next-line-or-next-page
   :n "s-<mouse-4>"  #'pdf-view-previous-line-or-previous-page
   ;; :n "."            #'hydra-pdftools/body
   ))

;; (eval-after-load 'interleave
;; (add-hook 'pdf-view-mode-hook #'brust-pdf-tools-hook t))

(defun brust-image-backward-hsroll-5 (args)
  (interactive "p")
  (brust-by-five #'image-backward-hscroll args))
(defun brust-image-forward-hsroll-5 (args)
  (interactive "p")
  (brust-by-five #'image-forward-hscroll args))
(defun brust-pdf-view-next-line-or-next-page-5 (args)
  (interactive "p")
  (brust-by-five #'pdf-view-next-line-or-next-page args))
(defun brust-pdf-view-previous-line-or-previous-page-5 (args)
  (interactive "p")
  (brust-by-five #'pdf-view-previous-line-or-previous-page args))
#+END_SRC

** Screenshot

Take fancy screenshots of my code [[https://github.com/tecosaur/screenshot][screenshot.el]].

#+begin_src elisp
(use-package! screenshot
  :commands screenshot
  :config
  (load-file (locate-library "screenshot.elc")))
#+end_src

** Scihub

#+begin_src elisp
(use-package! scihub
  :init
  (setq scihub-download-directory "~/Dropbox/bibliography/pdf/"
        scihub-open-after-download t
        scihub-fetch-domain 'scihub-fetch-domains-lovescihub
        scihub-homepage "https://sci-hub.se"))
#+end_src

** Turn grep "writable" buffer
#+BEGIN_SRC elisp
(use-package! wgrep
  :defer t
  :config
  (setq wgrep-auto-save-buffer t
        wgrep-enable-key "r"))
#+END_SRC

** Visual regexp
#+BEGIN_SRC elisp
(use-package! visual-regexp
  :commands (vr/replace vr/query-replace))
#+END_SRC

** Zoom
#+begin_src elisp
(use-package! zoom
  :defer t
  :init
  (setq zoom-size '(0.618 . 0.618)
        zoom-ignored-major-modes '("dired-mode"
                                   "ediff-mode"
                                   ;; "eshell-mode"
                                   ;; "neotree-mode"
                                   "sr-speedbar-mode")
        zoom-ignored-buffer-name-regexps '("^*calc" "^\\*magit: +.*"))
  (add-hook! 'emacs-startup-hook (zoom-mode +1)))

(after! ediff
  (add-hook! 'ediff-before-setup-hook (zoom-mode -1))
  (add-hook! 'ediff-cleanup-hook (zoom-mode +1)))
#+end_src
