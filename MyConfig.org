#-*- mode: org -*-
#+TITLE=Main config file
#+STARTUP:overview

#+begin_quote
(What the world needs (I think) is not
      (a Lisp (with fewer parentheses))
      but (an English (with more.)))
-- Brian Hayes, http://tinyurl.com/3y9l2kf
#+end_quote

#+begin_quote
 Emacs is a flexible platform for developing end-user applications
   –unfortunately it is generally perceived as merely a text editor.
Some people use it specifically for one or two applications.
-- https://alhassy.github.io/init/
#+end_quote

#+begin_quote
I’m rarely happier than when spending an entire day programming my computer
  to perform automatically a task that would otherwise take me a
  good ten seconds to do by hand.
-- Douglas Adams
#+end_quote

#+begin_quote
“You don’t have to like Emacs to like it.”
-- https://www.gnu.org/software/emacs/manual/html_node/eintr/Emacs-Initialization.html
#+end_quote

* init.el
** Generic settings
*** Personal data
#+BEGIN_SRC elisp
(setq user-full-name "Laura Brustenga i Moncusí"
      user-mail-address "laurea987@gmail.com")
#+END_SRC
*** Scratch message
#+BEGIN_SRC elisp
  ;; (setq initial-scratch-message ";;;;;;;;;;;;; Bon Dia!!!! ;;;;;;;;;;;;;;;;\n\n\n")
  (setq initial-scratch-message ";; ╔═╗┌─┐┬─┐┌─┐┌┬┐┌─┐┬ ┬\n;; ╚═╗│  ├┬┘├─┤ │ │  ├─┤\n;; ╚═╝└─┘┴└─┴ ┴ ┴ └─┘┴ ┴\n")
#+END_SRC
*** European agenda.
#+BEGIN_SRC elisp
(setq european-calendar-style t
      calendar-week-start-day 1)
#+END_SRC

*** Local Variables
    Set save all local variable and do not query.
#+BEGIN_SRC elisp
;; (setq enable-local-variables :all)
(setq safe-local-variable-values
      '((brust-vterm-process . "vterm<1>")
        (brust-vterm-process . "vterm")))
#+END_SRC

#+RESULTS:
: :all

*** Killing Emacs with no questions
#+BEGIN_SRC elisp
(setq confirm-kill-emacs nil)

;; ;; (require 'cl)
;; (defun brust-save-buffers-kill-emacs-advice (orig-fun &rest args)
;;   (brust-update-personal-words)
;;   (cl-flet ((process-list ()))
;;     (apply orig-fun args)))

;; (advice-add 'save-buffers-kill-emacs :around #'brust-save-buffers-kill-emacs-advice)
;; (advice-add 'save-buffers-kill-terminal :around #'brust-save-buffers-kill-emacs-advice)
#+END_SRC
*** Clipboard
     Save whatever in the current (system) clipboard before replacing it with the Emacs' text.
#+BEGIN_SRC elisp
  (setq save-interprogram-paste-before-kill t
        ;; kill-ring-max 50
        )
#+END_SRC

#+RESULTS:
: t

*** Delete selection on type.
#+BEGIN_SRC elisp
(delete-selection-mode +1)
;; (setq delete-selection-save-to-register 'kill-ring)
#+END_SRC
*** Faces
#+begin_src elisp
(custom-set-faces
 ;; custom-set-faces was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(highlight ((t (:background "#51afef" :foreground "black" :weight bold)))))
#+end_src
** Doom stuff
*** Buffer line numbers
#+begin_src elisp
;; Line numbers are pretty slow all around. The performance boost of
;; disabling them outweighs the utility of always keeping them on.
(setq display-line-numbers-type nil)
;; (global-display-line-numbers-mode -1)
#+end_src
*** Dashboard menu
#+begin_src elisp
(setq +doom-dashboard-menu-sections
      '(
        ("Load workspace" :icon
         (all-the-icons-octicon "rocket" :face 'doom-dashboard-menu-title)
         :action +workspace/load)
        ("Email"
         :icon (all-the-icons-octicon "mail" :face 'font-lock-keyword-face)
         :action mu4e)
        ;; ("Open register" :icon
        ;;  (all-the-icons-octicon "bookmark" :face 'doom-dashboard-menu-title)
        ;;  :action jump-to-register)
        ;; ("Jump to bookmark"
        ;;  :icon (all-the-icons-octicon "bookmark" :face 'doom-dashboard-menu-title)
        ;;  :action bookmark-jump)
        ("Open org-agenda" :icon
         (all-the-icons-octicon "calendar" :face 'doom-dashboard-menu-title)
         :when
         (fboundp 'org-agenda)
         :action org-agenda)
        ("Reload last session" :icon
         (all-the-icons-octicon "history" :face 'doom-dashboard-menu-title)
         :when
         (file-exists-p
          (expand-file-name persp-auto-save-fname persp-save-dir))
         :face
         (:inherit
          (doom-dashboard-menu-title bold))
         :action doom/quickload-session)
        ("Open private configuration"
         :icon (all-the-icons-octicon "tools" :face 'doom-dashboard-menu-title)
         :when (file-directory-p doom-private-dir)
         :action doom/open-private-config)
        ;; ("Notes"
        ;;  :icon (all-the-icons-octicon "light-bulb" :face 'font-lock-keyword-face)
        ;;  :action ragone-deft-or-close)
        ;; ("Passwords"
        ;;  :icon (all-the-icons-octicon "lock" :face 'font-lock-keyword-face)
        ;;  :action pass)
        ;; ("IRC"
        ;;  :icon (all-the-icons-faicon "comments" :face 'font-lock-keyword-face)
        ;;  :action =irc)))
        ))
#+end_src
*** Formater
#+begin_src elisp
(setq +format-on-save-enabled-modes
      '(not emacs-lisp-mode  ; elisp's mechanisms are good enough
            sql-mode         ; sqlformat is currently broken
            tex-mode         ; latexindent is broken
            c-mode
            latex-mode))
#+end_src

#+RESULTS:
| not | emacs-lisp-mode | sql-mode | tex-mode | c-mode | latex-mode |

*** Lookup online
- Thresauros for synonyms.
#+begin_src elisp
(setq +lookup-provider-url-alist
      '(;; ("Doom Emacs issues" "https://github.com/hlissner/doom-emacs/issues?q=is%%3Aissue+%s")
        ("Google"            +lookup--online-backend-google "https://google.com/search?q=%s")
        ("Wikipedia"         "https://wikipedia.org/search-redirect.php?language=en&go=Go&search=%s")
        ("Singular Manual"   "https://www.google.com/search?q=site:www.singular.uni-kl.de+%s")
        ("Project Gutenberg" "http://www.gutenberg.org/ebooks/search/?query=%s")
        ;; ("DuckDuckGo"        +lookup--online-backend-duckduckgo "https://duckduckgo.com/?q=%s")
        ("DevDocs.io"        "https://devdocs.io/#q=%s")
        ("StackOverflow"     "https://stackoverflow.com/search?q=%s")
        ("Github"            "https://github.com/search?ref=simplesearch&q=%s")
        ("Youtube"           "https://youtube.com/results?aq=f&oq=&search_query=%s")
        ("Wolfram alpha"     "https://wolframalpha.com/input/?i=%s")
        ("Google images"     "https://www.google.com/images?q=%s")
        ("Google maps"       "https://maps.google.com/maps?q=%s")
        ))
#+end_src

#+RESULTS:
| Google            | +lookup--online-backend-google                                        | https://google.com/search?q=%s |
| Wikipedia         | https://wikipedia.org/search-redirect.php?language=en&go=Go&search=%s |                                |
| Singular Manual   | https://www.google.com/search?q=site:www.singular.uni-kl.de+%s        |                                |
| Project Gutenberg | http://www.gutenberg.org/ebooks/search/?query=%s                      |                                |
| DevDocs.io        | https://devdocs.io/#q=%s                                              |                                |
| StackOverflow     | https://stackoverflow.com/search?q=%s                                 |                                |
| Youtube           | https://youtube.com/results?aq=f&oq=&search_query=%s                  |                                |
| Google images     | https://www.google.com/images?q=%s                                    |                                |
| Google maps       | https://maps.google.com/maps?q=%s                                     |                                |

*** Mode Line
**** Do not show
#+begin_src elisp
(add-hook! 'emacs-startup-hook
  (setq column-number-mode nil
        size-indication-mode nil
        doom-modeline-buffer-encoding nil
        line-number-mode nil))
#+end_src

**** Show size: Total number of lines
***** New face (small and grey)
#+begin_src elisp
(make-face 'mode-line-top-line-number)

(set-face-attribute
 'mode-line-top-line-number nil
 :inherit 'mode-line
 :foreground "gray60" :height 0.7)
#+end_src

#+RESULTS:

***** Mode line string
#+begin_src elisp
(defsubst brust-line-number-mode--string nil
  "Show current line/buffer total number of lines."
  (concat (doom-modeline-spc)
          ;; (:propertize "\[" face mode-line-bars-face)
          (propertize "%l"
                      'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                      'help-echo "Buffer size mouse-1: Display Line and Column Mode Menu"
                      'mouse-face 'mode-line-highlight
                      'local-map mode-line-column-line-number-mode-map)
          (propertize (if brust-line-number-mode-show-total
                          (concat "/" (brust--number-of-lines-current-buffer))
                        "")
                      'face 'mode-line-top-line-number)
          (doom-modeline-spc)))
#+end_src

#+RESULTS:
: brust-line-number-mode--string

***** Minor mode
#+begin_src elisp
(define-minor-mode brust-line-number-mode
  "Toggle line number display in the mode line (Brust Line Number mode).
With a prefix argument ARG, enable Line Number mode if ARG is
positive, and disable it otherwise.  If called from Lisp, enable
the mode if ARG is omitted or nil.

Line numbers do not appear for very large buffers and buffers
with very long lines; see variables `line-number-display-limit'
and `line-number-display-limit-width'."
  :init-value t :global t :group 'mode-line
  (or global-mode-string (setq global-mode-string '("")))
  (setq global-mode-string
        (delete '(:eval (brust-line-number-mode--string)) global-mode-string))
  (if brust-line-number-mode
      (unless (member '(:eval (brust-line-number-mode--string)) global-mode-string)
        (setq global-mode-string
              (append global-mode-string '((:eval (brust-line-number-mode--string))))))))

(defcustom brust-line-number-mode-show-total t
  "Show buffer's total number of lines in mode-line"
  :group 'brust-line-number-mode
  :type 'bool)

;; (add-hook! 'emacs-startup-hook
;;   (setq global-mode-string '("" (:eval (brust-line-number-mode--string)) display-time-string)))
#+end_src

#+RESULTS:
: brust-line-number-mode-show-total
***** Activate
#+begin_src elisp
(brust-line-number-mode +1)
#+end_src

**** Display time
#+begin_src elisp
(defun brust-kill-date nil
  (interactive)
  (kill-new (format-time-string "%e/%m/%Y" (current-time))))

(defun brust-message-date nil
  (interactive)
  (message (format-time-string "w%Wd%j %A, %e %B %Y, (%e/%m/%Y - %R %Z) -- %s" (current-time))))

;; Time format
(add-hook! 'emacs-startup-hook
  (customize-set-variable 'display-time-string-forms
                          '((propertize (concat " " 12-hours ":" minutes am-pm " ")
                                        'face 'mode-line
                                        'help-echo "Current date: mouse 1 show, mouse 3 kill"
                                        'keymap '(mode-line keymap
                                                            (mouse-3 . brust-kill-date)
                                                            (mouse-1 . brust-message-date)))))
  (setq display-time-default-load-average nil)
  (display-time-mode +1))
#+end_src

#+RESULTS:
: t

**** COMMENT Use buffer-name for buffer name
#+begin_src elisp
(setq doom-modeline-buffer-file-name-style 'buffer-name)
#+end_src
*** TODO Persp
#+begin_src elisp
(setq persp-save-dir (expand-file-name "~/.doom.d/local/workspaces/")
      persp-auto-save-persps-to-their-file-before-kill t)
;; persp-save-to-file-by-names
#+end_src
*** Real buffers
See =doom-unreal-buffer-functions=
#+begin_src elisp
(defvar brust-doom-my-real-buffers
  (list "singular"
        "julia"
        "M2"
        "helpful"
        "^[*]Org Src" )
  "List of my real buffers: please Doom do not diminish them!")

(defun brust-string-match-p (string regexp &optional START)
  "Same as `string-match-p' with swap arguments. For testing membership of a string in a list of regexp."
  (string-match-p regexp string START))

(defun brust-doom-my-real-buffers-p (buffer)
  "Test whether some regexp in `brust-doom-my-real-buffers' matches buffer's name of `buffer'"
  (cl-member (buffer-name buffer) brust-doom-my-real-buffers :test #'brust-string-match-p))

(when doom-real-buffer-functions
  (setq doom-real-buffer-functions
        (append
         doom-real-buffer-functions
         '(brust-doom-my-real-buffers-p))))
#+end_src

*** Scratch mode
#+begin_src elisp
(setq doom-scratch-initial-major-mode 'lisp-interaction-mode)
#+end_src

#+RESULTS:
: lisp-interaction-mode

*** Visual fill mode
    It is like visual line mode but breaks the lines at =fill-column=
#+begin_src elisp
;; For visual-fill-mode see https://github.com/hlissner/doom-emacs/pull/1906/files
(setq +word-wrap-extra-indent 'single
      ;; +word-wrap-fill-style 'soft
      )

(add-hook! 'emacs-startup-hook
  (+global-word-wrap-mode +1)
  (add-to-list '+word-wrap-disabled-modes 'emacs-lisp-mode)
  (add-to-list '+word-wrap-visual-modes 'org-mode))
#+end_src

** TODO Handy Doom
*** File templates
Add my own templates for LaTeX, Singular, Julia... Looks pretty handy :)
Copy folder module in local to .emacs.d (I'm making your live easier)
#+begin_src elisp
(set-file-template! "[.]sing" :trigger "__sing" :mode 'c++-mode)
(set-file-template! "[.]tex" :trigger "__tex" :mode 'latex-mode)
#+end_src

#+RESULTS:

*** TODO My Projects
*** TODO Rotate text
Rotate text under cursor under pre-establish patterns
For example, var1, var2, ... varN
See [[https://github.com/debug-ito/rotate-text.el/blob/master/rotate-text.el][Rotate Text]]
** Bindings
#+begin_src elisp
(map!
 ;; s- commands: commands executed several times AND in several distinct modes.
 "s-s"      #'save-buffer
 "s-w"      #'evil-window-next
 ;; "s-c"      #'close-quoted-open-paren-right-or-left-end-of-line
 "s-c"      #'close-quoted-open-paren-right-or-left
 ;; "s-SPC"    #'brust-cycle-whitespace ;; I am used to 'g SPC'
 "s-h"      #'recenter-top-bottom
 ;; "s-f"      #'flyspell-correct-previous ;; Learning to use z=
 ;; s- motion command
 "s-j"      #'evil-scroll-down
 "s-k"      #'evil-scroll-up
 ;; Cycling in kill-ring
 ;; "C-P"      #'brust-evil-paste-pop-backwards ;; see C-n
 "M-p"      #'counsel-yank-pop
 ;; :ier "M-i" #'evil-normal-state ;; it was tab-to-tab-stop
 ;; Now I use evil-escape (equivalent to key-chords jk kj) Press them a single key!

 ;; Normal mode workarounds (keep it to minimum)
 ;; :n "u"     #'emacs-undo ;; now undo works fine
 :nim "C-e" #'doom/forward-to-last-non-comment-or-eol
 :n "q"     #'kill-current-buffer
 :n "Q"     #'mark-whole-buffer ;; was undefined
 :i "C-,"   #'brust-correct-prev-spelling
 ;; :nvmro "w" #'evil-backward-word-begin
 ;; :nvmro "W" #'evil-backward-WORD-begin
 ;; :n "H"     #'recenter-top-bottom ;; There is no difference with s-h
 ;; More handy TABs (From Hlissner)
 :n [tab] (general-predicate-dispatch nil
            (fboundp 'evil-jump-item)
            #'evil-jump-item)

 :v [tab] (general-predicate-dispatch nil
            (and (bound-and-true-p yas-minor-mode)
                 (or (eq evil-visual-selection 'line)
                     (not (memq (char-after) (list ?\( ?\[ ?\{ ?\} ?\] ?\))))))
            #'yas-insert-snippet
            (fboundp 'evil-jump-item)
            #'evil-jump-item)

 ;; Personal extensions
 "<f2>"  #'brust-correct-prev-spelling
 "<f5>"  #'counsel-kmacro
 "<f9>"  #'mu4e
 "<f10>" #'magit-status
 :n "g SPC" #'brust-cycle-whitespace ;; It was unbind
 (:prefix "z"
  :n "j" #'brust-correct-prev-spelling
  :n "k" #'brust-correct-prev-spelling)
 (:leader
  :desc "locleader" "SPC" nil ;; Unbind "SPC SPC"
  :desc "Delete other windows" "w 0" #'delete-other-windows
  ;; :desc "Rotate anticlockwise" "w a" #'rotate-frame-anticlockwise
  ;; :desc "Switch buffer"              "b b" #'ivy-switch-buffer

  ;; My global bindings of Laura: functions used everywhere but not so often.
  (:prefix ("l" . "BMO")
   "n"    #'endless/narrow-or-widen-dwim
   "i"    #'endless/ispell-word-then-abbrev
   ;; "%"    #'vr/replace
   "%"    #'vr/query-replace
   "<f3>" #'kmacro-query-my
   ;; Zooming in emacs
   "1"    #'zoom-out ;; enlarge font
   "2"    #'zoom-in ;; reduce font
   (:prefix ("a" . "accents")
    ;; Easy Catala i Castella
    :desc "Insert ç" "c" (lambda nil (interactive) (insert "ç"))
    :desc "Insert Ç" "C" (lambda nil (interactive) (insert "Ç"))
    :desc "Insert ñ" "n" (lambda nil (interactive) (insert "ñ"))
    :desc "Insert Ñ" "N" (lambda nil (interactive) (insert "Ñ"))
    :desc "Insert à" "a" (lambda nil (interactive) (insert "à"))
    :desc "Insert À" "A" (lambda nil (interactive) (insert "À"))
    :desc "Insert è" "e" (lambda nil (interactive) (insert "è"))
    :desc "Insert È" "E" (lambda nil (interactive) (insert "È"))
    :desc "Insert é" "r" (lambda nil (interactive) (insert "é"))
    :desc "Insert É" "R" (lambda nil (interactive) (insert "É"))
    :desc "Insert í" "i" (lambda nil (interactive) (insert "í"))
    :desc "Insert Í" "I" (lambda nil (interactive) (insert "Í"))
    :desc "Insert ï" "k" (lambda nil (interactive) (insert "ï"))
    :desc "Insert Ï" "K" (lambda nil (interactive) (insert "Ï"))
    :desc "Insert ò" "o" (lambda nil (interactive) (insert "ò"))
    :desc "Insert Ò" "O" (lambda nil (interactive) (insert "Ò"))
    :desc "Insert ó" "p" (lambda nil (interactive) (insert "ó"))
    :desc "Insert Ó" "P" (lambda nil (interactive) (insert "Ó"))
    :desc "Insert ú" "u" (lambda nil (interactive) (insert "ú"))
    :desc "Insert Ú" "U" (lambda nil (interactive) (insert "Ú"))
    :desc "Insert ü" "j" (lambda nil (interactive) (insert "ü"))
    :desc "Insert Ü" "J" (lambda nil (interactive) (insert "Ü"))
    )))
 )
#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (insert Ü) |

** My functions
*** COMMENT Add blank pages to a pdf
#+BEGIN_SRC elisp
  (defun brust-pdf-add-blank-pages (-file init-page)
    (interactive
     (list  (read-file-name "Pdf to modify: ")
            (read-number "Page to start adding blank pages: ")))
    (let (-num -page (i init-page) -commstr)
      (with-temp-buffer
        (insert (shell-command-to-string (format "pdftk %s dump_data" -file)))
        (goto-char (point-min))
        (re-search-forward "NumberOfPages: \\([0-9]+\\)$" nil t)
        (setq -num (- (string-to-number (match-string 1)) i))
        (setq -page
              (if (re-search-forward "PageMediaDimensions: \\([0-9]+\\) \\([0-9]+\\)$" nil t)
                  (concat (match-string 1) "x" (match-string 2))
                "a4")))
      (setq -commstr
            (concat (format "A1-%d " i)
                    (cl-loop repeat -num
                             concat (format "B1 A%d " (setq i (1+ i))))))
      (let ((-blanche (concat (file-name-directory -file) "pageblanche.pdf"))
            (-mod (concat (file-name-directory -file) "mod_" (file-name-base -file) ".pdf"))
            (-out (concat (file-name-directory -file) "print_" (file-name-base -file) ".pdf")))
        (shell-command (format "convert xc:none -page %s %s" -page -blanche))
        (shell-command (format "pdftk A=%s B=%s cat %s output %s" -file -blanche -commstr -mod))
        (shell-command (format "rm %s" -blanche)))))
  ;; (shell-command (format "pdfnup %s --nup 2x1 --landscape --outfile %s" -mod -out))
  ;; (shell-command (format "rm %s && rm %s" -mod -blanche)))))
#+END_SRC

#+RESULTS:
: brust-pdf-add-blank-pages

*** By five
#+BEGIN_SRC elisp
  (defun brust-by-five (-function args)
    (funcall-interactively -function (if (numberp args)
                                         (* 5 args)
                                       5)))
#+END_SRC

#+RESULTS:
: brust-by-five

*** Change font size
#+begin_src elisp
  (defun zoom-in nil
    (interactive)
    (set-face-attribute 'default nil :height (+ (face-attribute 'default :height) 10)))

  (defun zoom-out nil
    (interactive)
    (set-face-attribute 'default nil :height (- (face-attribute 'default :height) 10)))
#+end_src

*** Close<->open parents
**** Parenthesis syntax.
#+BEGIN_SRC elisp
  (defconst all-paren-syntax-table
     (let ((table (make-syntax-table)))
       (modify-syntax-entry ?{  "(}" table)
       (modify-syntax-entry ?}  "){" table)
       (modify-syntax-entry ?\( "()" table)
       (modify-syntax-entry ?\) ")(" table)
       (modify-syntax-entry ?\[ "(]" table)
       (modify-syntax-entry ?\] ")[" table)
       (modify-syntax-entry ?\\ "'"  table)
       ;; (modify-syntax-entry ?\< "(>" table)
       ;; (modify-syntax-entry ?\> ")<" table)
       table)
     "A syntax table giving all parenthesis parenthesis syntax.")
#+END_SRC

**** Generic function
#+BEGIN_SRC elisp
(defun close-quoted-open-paren (args dir)
  "dir=0 -> right, dir=1 -> left"
  (with-syntax-table all-paren-syntax-table
    (cl-loop repeat args do
             (let* ((i dir)
                    (pos (save-excursion (up-list (1- (* 2 dir))) (point)))
                    (closing (matching-paren (char-after (- pos dir)))))
               (while (eq (char-before (- pos i)) ?\\)
                 (setq i (1+ i)))
               (cl-loop repeat (- i dir) do
                        (progn
                          (unless (or (eolp) (evil-insert-state-p)) (forward-char +1))
                          (insert "\\")
                          ))
               (unless (or (eolp) (evil-insert-state-p)) (forward-char +1))
               (insert closing)
               (backward-char (* dir i)))))
  t)
#+END_SRC

**** By right
#+BEGIN_SRC elisp
  (defun close-quoted-open-paren-right (&optional args)
    (interactive "P")
    (close-quoted-open-paren (if (numberp args) args 1) 0))

  (defun close-all-open-paren-right nil
    (interactive)
    (while (ignore-errors (close-quoted-open-paren-right))))

#+END_SRC
**** By left
#+BEGIN_SRC elisp
  (defun close-quoted-open-paren-left (&optional args)
    (interactive "P")
    (close-quoted-open-paren (if (numberp args) args 1) 1))

  (defun close-all-open-paren-left nil
    (interactive)
    (while (ignore-errors (close-quoted-open-paren-left))))
#+END_SRC
**** By right or left
#+BEGIN_SRC elisp
(defun my-texmathp nil
  (interactive)
  (when (texmathp)
    (let ((pnt (point))
          (p (ignore-errors
               (goto-char (cdr texmathp-why))
               (sp-forward-sexp 1))))
      (goto-char pnt)
      p)))

(defun close-quoted-open-paren-right-or-left (&optional args)
  (interactive "P")
  (or args (setq args 1))
  (cl-loop repeat args do
           (if (and (fboundp 'texmathp)
                    (my-texmathp))
               (unless (and (ignore-errors (close-quoted-open-paren-right))
                            (if (my-texmathp) t (delete-char -2) nil))
                 (unless (and (ignore-errors (close-quoted-open-paren-left))
                              (if (my-texmathp) t (delete-char 2) nil))))
             (unless (ignore-errors (close-quoted-open-paren-right))
               (unless (ignore-errors (close-quoted-open-paren-left)))))))

(defun close-quoted-open-paren-right-or-left-end-of-line (&optional args)
  (interactive "P")
  (when (not (string= (thing-at-point 'char) " ")) (move-end-of-line 1))
  (close-quoted-open-paren-right-or-left args))
#+END_SRC

#+RESULTS:
: close-quoted-open-paren-right-or-left-end-of-line

*** Customize face at point
    A handy function for customization
#+BEGIN_SRC elisp
  (defun customize-face-at-point nil
    "Customize face which point is at."
    (interactive)
    (let ((face (get-text-property (point) 'face)))
      (if face
          (customize-face face)
        (message "No face defined at point"))))

#+END_SRC
*** Delete region advise
#+begin_src elisp
(defun brust-return-buffer-substring-advice (orig-fun &rest args)
  "Same as 'delete-region' but returns the deleted string"
  (let ((str (apply 'buffer-substring args)))
    (apply orig-fun args)
    str))

(advice-add 'delete-region :around #'brust-return-buffer-substring-advice)

#+end_src
*** Double Capitals
    Convert words in DOuble CApitals to Single Capitals.
    [[https://emacs.stackexchange.com/questions/13970/fixing-double-capitals-as-i-type][From StackExange]]

**** The function
#+BEGIN_SRC elisp
(defun brust-dcaps-to-scaps nil
  (save-excursion
    (let ((end (point)))
      (and (= -3 (skip-syntax-backward "w"))
           (let (case-fold-search)
             (looking-at-p "\\b[[:upper:]]\\{2\\}[[:lower:]]"))
           (capitalize-region (point) end)))))

(defun dcaps-to-scaps nil
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (when (= ?w (char-syntax (char-before)))
    (brust-dcaps-to-scaps)))

(defun dcaps-to-scaps-notinmath nil
  "Convert word in DOuble CApitals to Single Capitals."
  (interactive)
  (when (and (= ?w (char-syntax (char-before)))
             (not (texmathp)))
    (brust-dcaps-to-scaps)))
#+END_SRC
**** New minor mode
#+BEGIN_SRC elisp
(defun brust-dcaps-to-scaps-notinmath-p nil
  (or (derived-mode-p 'latex-mode)
      (eq major-mode 'org-mode)))

(define-minor-mode dubcaps-mode
  "Toggle `dubcaps-mode'.  Converts words in DOuble CApitals to
Single Capitals as you type."
  :init-value nil
  :lighter ("") ;; String to show in mode-line
  (if dubcaps-mode
      (if (brust-dcaps-to-scaps-notinmath-p)
          (add-hook 'post-self-insert-hook #'dcaps-to-scaps-notinmath nil 'local)
        (add-hook 'post-self-insert-hook #'dcaps-to-scaps nil 'local))
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps 'local)
    (remove-hook 'post-self-insert-hook #'dcaps-to-scaps-notinmath 'local)))
#+END_SRC


**** Activation
#+BEGIN_SRC elisp
(add-hook 'text-mode-hook #'dubcaps-mode)
#+END_SRC

*** COMMENT Find file sudo
#+BEGIN_SRC elisp
(defun find-file-sudofying (FILENAME &optional WILDCARDS)
  "Find file as root if necessary."
  (when (and
         buffer-file-name
         (not (file-writable-p buffer-file-name))
         ;; (called-interactively-p "any")
         (y-or-n-p "File not writable. Open it as root?"))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(advice-add 'find-file :after #'find-file-sudofying)
#+END_SRC

#+RESULTS:
*** Line by line
#+begin_src elisp
(defun brust-buffer-advice-line-by-line (FUNCTION &rest ARGS)
  "Executes function FUNCTION, from point-min, and moves forward one line. Repeat until end of buffer."
  (save-excursion
    (goto-char (point-min))
    (while (not (eobp))
      (apply FUNCTION ARGS)
      (forward-line +1))))
#+end_src

#+RESULTS:

*** Macro query
#+BEGIN_SRC elisp
(defun kmacro-query-my (arg)
  "Prompt for input using minibuffer during kbd macro execution.
   With prefix argument, allows you to select what prompt string to use.
   If the input is non-empty, it is inserted at point."
  (interactive "P")
  (let* ((prompt (if arg (read-from-minibuffer "PROMPT: ") "Input: "))
         (input (minibuffer-with-setup-hook (lambda nil (kbd-macro-query t))
                  (read-from-minibuffer prompt))))
    (unless (string= "" input) (insert input))))


#+END_SRC

#+RESULTS:
: kmacro-query-my

*** Mouse wheel
    Mouse wheel: try it with S and C
**** Functions
#+BEGIN_SRC elisp
(defun up-slightly (args) (interactive "p") (brust-by-five #'scroll-up args))
(defun down-slightly (args) (interactive "p") (brust-by-five #'scroll-down args))

(defun up-one nil (interactive) (scroll-up 1))
(defun down-one nil (interactive) (scroll-down 1))

(defun up-a-lot nil (interactive) (scroll-up))
(defun down-a-lot nil (interactive) (scroll-down))

#+END_SRC

**** Keybindings
#+BEGIN_SRC elisp
(global-set-key [mouse-4] 'down-slightly)
(global-set-key [mouse-5] 'up-slightly)

(global-set-key [S-mouse-4] 'down-one)
(global-set-key [S-mouse-5] 'up-one)

(global-set-key [C-mouse-4] 'down-a-lot)
(global-set-key [C-mouse-5] 'up-a-lot)
#+END_SRC

*** Narrow or widen dwin
 There's a nice helper from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless Parentheses]] that defines a do-what-I-mean version
 of the narrow-or-widen so I don't have to keep remembering which is which.
#+BEGIN_SRC elisp
  (defun endless/narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or
  defun, whichever applies first. Narrowing to
  org-src-block actually calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer
  is already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p)
                (not p))
           (widen)
           (let ((recenter-redisplay t))
             (recenter nil)))
          ((region-active-p)
           (narrow-to-region (region-beginning)
                             (region-end))
           (deactivate-mark)
           (goto-char (point-min)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if
           ;; you don't want it.
           (cond ((ignore-errors (org-edit-src-code) t)
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((and (derived-mode-p 'latex-mode)
                (ignore-errors (LaTeX-narrow-to-environment))))
          ((derived-mode-p 'emacs-lisp-mode)
           (narrow-to-defun))
          (t
           (brust-narrow-to-paragraph))))
#+END_SRC

#+RESULTS:
: endless/narrow-or-widen-dwim

*** Org mode eval all elisp src blocks under current header
#+BEGIN_SRC elisp
(defun brust-endless/org-eval-current-header nil
  (interactive)
  (brust-endless/org-eval-eblocks
   (and (org-copy-subtree)
        (pop kill-ring))))
#+END_SRC
*** COMMENT PDF From MR to pdf
commands to work with MangaRock comics
#+BEGIN_SRC bash
  cd "~/Dropbox/files/26897765-1546816941953/"
  parallel convert '{} {.}.pdf' ::: * && pdftk `ls | grep "pdf" | sort -n` cat output Vol-2.pdf
#+END_SRC

#+RESULTS:

*** Prompt in Singular... Non-editable
#+begin_src elisp
        (defvar brust-math-software-buffers-prompts
          '(("*julia*"    . "^julia>")
            ("*singular*" . "^>"))
          "List of cons with buffer names runing some math software and a regex for its promp string")

        (defun brust-math-software-intangify-buffer-text (-regexp beg end)
          "Set cursor-intangible property to all buffer text maching regular expresion `-regexp` between `beg` and  `end`"
          (save-excursion
            (goto-char beg)
            (save-match-data
              (while (re-search-forward -regexp end t)
                (add-text-properties (1- (match-beginning 0)) (match-end 0) '(cursor-intangible t rear-nonsticky nil))))))

        (defun brust-math-software-intangify-cursor-on-prompt (beg end length)
          "Set cursor-intangible in math software buffers prompts"
          (let ((-prompt (cdr (assoc (buffer-name) brust-math-software-buffers-prompts))))
            (when -prompt
              (brust-math-software-intangify-buffer-text -prompt beg end))))

        (defun brust-math-software-hookfun-to-intangify-prompt nil
          (cursor-intangible-mode 1)
          (add-hook 'after-change-functions #'brust-math-software-intangify-cursor-on-prompt nil t))
#+end_src

#+RESULTS:
: brust-math-software-hookfun-to-intangify-prompt

*** RGB color (get numbers)
#+begin_src elisp
(defvar brust-colors-rgb-decimal-points 1 "Number of decimal points rounding RGB colors")
(defvar brust-colors-rgb-separator "," "SEPARATOR between numbers")

(defun brust-round (list-of-num)
  (let ((rounding (* 10 brust-colors-rgb-decimal-points)))
    (cl-loop for x in list-of-num
             collect (/ (fround (* rounding x)) rounding))))

(defun brust-colors-num-to-str (color)
  (mapconcat #'number-to-string color brust-colors-rgb-separator))

(defun brust-colors-insert-rgb (color)
  "Insert the RGB value 'num1,num2,num3' with num between 0 and 1"
  (insert (brust-colors-num-to-str (color-name-to-rgb color))))

(defun brust-colors-insert-rounded-rgb (color)
  "Insert the RGB value 'num1,num2,num3' with num between 0 and 1"
  (insert (brust-colors-num-to-str (brust-round (color-name-to-rgb color)))))

(defun brust-colors-kill-rgb (color)
  "Insert the RGB value 'num1,num2,num3' with num between 0 and 1"
  (kill-new (brust-colors-num-to-str (color-name-to-rgb color))))

(defun brust-colors-kill-rounded-rgb (color)
  "Insert the RGB value 'num1,num2,num3' with num between 0 and 1"
  (kill-new (brust-colors-num-to-str (brust-round (color-name-to-rgb color)))))

(after! ivy
  (ivy-add-actions
   'counsel-colors-emacs
   '(("g" brust-colors-insert-rgb "insert RGB value")
     ("r" brust-colors-insert-rounded-rgb "insert round RGB value")
     ("G" brust-colors-kill-rgb "kill RGB value")
     ("R" brust-colors-kill--rounded-rgb "kill round RGB value")))
  (ivy-add-actions
   'counsel-colors-web
   '(("g" brust-colors-insert-rgb "insert RGB value")
     ("r" brust-colors-insert-rounded-rgb "insert round RGB value")
     ("G" brust-colors-kill-rgb "kill RGB value")
     ("R" brust-colors-kill-rounded-rgb "kill round RGB value")))
  )
#+end_src
*** Spelling
#+begin_src elisp
(defun brust-correct-prev-spelling nil
  (interactive)
  (save-excursion
    (+spell/previous-error)
    (+spell/correct)))
#+end_src

#+RESULTS:
: brust-correct-prev-spelling

*** Total number of lines
#+begin_src elisp
(defsubst brust--number-of-lines-current-buffer nil
  (let ((n (string-to-number
            (save-excursion
              (goto-char (point-max))
              (format-mode-line "%l")))))
    (s-trim
     (cond
      ((> n 1000000) (format "%7.1fM" (/ n 1000000.0)))
      ((> n 1000) (format "%7.1fk" (/ n 1000.0)))
      ;;((> n 100) (format "%7.1fh" (/ n 100.0)))
      (t (format "%8d" n))))))
#+end_src

#+RESULTS:
: brust--number-of-lines-current-buffer

*** Word count
#+BEGIN_SRC elisp
  (defun brust-wc-get-word-count-list-of-current-project nil
    (let ((project-master (expand-file-name (TeX-master-file t nil t))))
      (with-temp-buffer
        (call-process-shell-command
         (concat "texcount -opt="
                 (expand-file-name "~/Dropbox/config/TeXcount-emacs.txt")
                 " -dir="
                 (file-name-directory project-master)
                 " "
                 project-master)
         nil t)
        (re-search-backward
         "new\\([0-9]+\\)w\\([0-9]+\\)im\\([0-9]+\\)dm\\([0-9]+\\)cd\\([0-9]+\\)h\\([0-9]+\\)file" nil t)
        (cl-loop for xx from 1 to 6
                 if (= xx 3) collect (number-to-string (- (string-to-number (match-string-no-properties 3))
                                                          (string-to-number (match-string-no-properties 4))))
                 else
                 collect (match-string-no-properties xx)))))

  (defun brust-wc-save-words nil
    (interactive)
    (let ((wc-sat (brust-wc-get-word-count-list-of-current-project)))
      (find-file (concat
                  (file-name-directory (expand-file-name (TeX-master-file t nil t)))
                  "wc-statistics.txt"))
      (goto-char (point-max))
      (insert "\n" (format-time-string "%x, %X, ")
              (cl-loop for xx in wc-sat
                       concat (concat xx ", ")))
      (save-buffer)
      (kill-buffer)))

  (defun brust-wc-save-words-my-thesis nil
    (interactive)
    (find-file "~/Dropbox/Math/Doctorat_Laura/Thesis/master.tex")
    (brust-wc-save-words))
#+END_SRC

*** White space cycle
    This is a remake and merge of `cycle-spacing' `delete-blank-lines' and `xah-shrink-whitespaces'.
#+BEGIN_SRC elisp
  (defun brust-cycle-whitespace nil
    (interactive)
    (let* ((--pt0 (point))
           (--inline-skip-chars " \t\v\f")
           (--skip-chars " \t\v\f\n")
           (--beg (progn
                    (skip-chars-backward --skip-chars)
                    (constrain-to-field nil --pt0)
                    (point)))
           (--end (progn
                    (skip-chars-forward --skip-chars)
                    (constrain-to-field nil --pt0)
                    (point)))
           (--indent (buffer-substring-no-properties
                      (progn
                        (skip-chars-backward --inline-skip-chars)
                        (point))
                      --end))
           (--contex (buffer-substring --beg --end))
           (--lnum (1- (length (split-string --contex "\n")))))
      (cond
       ((or (not (equal last-command this-command))
            (not brust-cycle-whitespace--context))
        ;; Special handling for case where there was no space at all.
        (cond ((< --beg --end)
               (setq brust-cycle-whitespace--context ;;Save for later.
                     (cons --pt0 --contex))
               (delete-region --beg --end)
               (when (and (< (1+ --beg) --end)   ;; more than one space
                          (< --end (point-max))  ;; erase whitespace at eobp
                          (< (point-min) --beg)) ;; and at bobp
                 (insert
                  (cond ((< --lnum 2) " ")
                        ((< --lnum 3) (concat "\n" --indent))
                        (t (concat "\n\n" --indent))))))
              (t ;; indent when it is called without surrounding whitespaces.
               (end-of-line)
               (brust-cycle-whitespace))))
       ;; Final call: (and (equal last-command this-command) (equal --beg --end))
       ((not (< --beg --end))
        (insert (cdr brust-cycle-whitespace--context))
        (goto-char (car brust-cycle-whitespace--context))
        (setq cycle-spacing--context nil))
       ;; Intermadiate calls (and (equal last-command this-command) (< --beg --end))
       (t
        (delete-region --beg --end)
        (insert
         (cond ((< --lnum 1) "")
               ((< --lnum 2) " ")
               ((< --lnum 3) (concat "\n" --indent))
               (t (concat "\n\n" --indent))))))))
    ;; (more-expansions #'(brust-cycle-whitespace)))

  (defvar brust-cycle-whitespace--context nil
    "Store context used in consecutive calls to `brust-cycle-whitespace' command.
       The first time `brust-cycle-whitespace' runs, it saves in this variable:
       the original point position, and the original spacing around point.")

#+END_SRC
*** White space edit
#+begin_src elisp
(defun skip-white-space-forward nil
  (interactive)
  (skip-chars-forward  " \t\v\f\n")
  (point))

(defun delete-white-space (&optional start)
  (interactive)
  (delete-region (or start (point)) (skip-white-space-forward)))
#+end_src
** TODO Org mode
*** Config
 #+BEGIN_SRC elisp
(defun brust-org-my-defaults nil
  (setq
   ;; org-edit-src-auto-save-idle-delay 20
   org-cycle-global-at-bob t
   org-return-follows-link t
   org-hide-leading-stars nil
   org-ellipsis " ↴"
   ))

(after! org
  (add-hook 'org-mode-hook #'brust-org-my-defaults t)
  (map! :map org-mode-map
        "<" 'brust-org<
        (:localleader
         "SPC" (kbd "C-c C-c")
         :desc "Babel" "B" org-babel-map
         :desc "Biblio" "C" #'ivy-bibtex-with-local-bibliography
         )))
 #+END_SRC

*** TODO Agenda
#+begin_src elisp
(setq org-agenda-files (quote ("~/Dropbox/Org/" "~/Dropbox/bibliography/notes.org"))
      org-directory "~/Dropbox/Org/"
      org-agenda-todo-list-sublevels nil
      org-deadline-warning-days 3
      org-agenda-skip-scheduled-if-done 1
      org-agenda-skip-deadline-if-done 1
      org-agenda-skip-deadline-if-done 1
      org-agenda-custom-commands
      '(("h" "My agenda view"
         ((agenda "")
          (todo)))))
#+end_src
*** Exports
**** LaTeX

#+TITLE: 27 Cubics containing the reciprocal variety
#+AUTHOR: Laura Brustenga Moncusí
#+PROPERTY: header-args :eval never-export :cache no
#+PROPERTY: header-args+ :session *ob-ess-julia* :exports both
#+LATEX_HEADER: \usemintedstyle{tango}
#+LATEX_HEADER: \usepackage{polyglossia}
#+LATEX_HEADER: \setmonofont{DejaVu Sans Mono}[Scale=MatchLowercase]
#+LATEX_HEADER: \usepackage{unicode-math}
#+LATEX_HEADER: \renewcommand{\P}{\mathbb{P}} % Projective space
#+LATEX_HEADER: \renewcommand{\O}{\mathcal{O}}   % Calligraphic E
#+LATEX_HEADER: \renewcommand{\S}{\mathbb{S}}     % linear space of symmetric matrices
#+LATEX_HEADER: \newcommand{\Cat}{\mathrm{Cat}}   % Catalecticant matrix
#+LATEX_HEADER: \newcommand{\PGL}{\mathrm{PGL}}     % Projective general linear group
#+LATEX_HEADER: \newcommand{\Adj}{\mathrm{Adj}} % Adjugate matrix
#+OPTIONS: toc:nil
#+begin_src elisp
(after! org
  (setq org-latex-listings 'minted
        org-latex-packages-alist '(("" "minted"))
        org-latex-minted-langs '((ess-julia "julia")
                                 (julia-vterm "julia"))
        org-latex-pdf-process
        '("lualatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "lualatex -shell-escape -interaction nonstopmode -output-directory %o %f")
        org-latex-minted-options
        '(("breaklines" "")
          ;; ("escapeinside" "||")
          ("linenos" "")
          ("numbersep" "3pt")
          ("mathescape" "true")
          ;; ("gobble" "2")
          ("frame" "lines")
          ("framesep" "2mm")
          ;; ("fontsize" "\small")
          )))
#+end_src

#+RESULTS:
| breaklines |       |
| linenos    |       |
| numbersep  | 3pt   |
| mathescape | true  |
| frame      | lines |
| framesep   | 2mm   |

*** Captures
 #+BEGIN_SRC elisp
(after! org
  (setq org-capture-templates
        (append
         org-capture-templates
         `(
           ;; New Email
           ("e" "TODO respond to email"
            entry
            (file+headline "~/Dropbox/Org/my.org" "ToDo Miscellaneous")
            "* TODO %^{Description}\n%A\n%?\n")
           ;; Ledger
           ("l" "Ledger")
            ("lb" "Bank"
             plain
             (file ,(format "~/Dropbox/Org/ledger-%s.dat" (format-time-string "%Y")))
             ,my/org-ledger-card-template
             :empty-lines 1
             :immediate-finish t)
            ("lc" "Cash"
             plain
             (file ,(format "~/Dropbox/Org/ledger-%s.dat" (format-time-string "%Y")))
             ,my/org-ledger-cash-template
             :empty-lines 1
             :immediate-finish t)
           ;; Hugo
           ("h" "Hugo post"
            entry
            ;; It is assumed that below file is present in `org-directory'
            ;; and that it has a "Blog Ideas" heading. It can even be a
            ;; symlink pointing to the actual location of all-posts.org!
            (file+olp "my.org" "Blog Ideas")
            (function org-hugo-new-subtree-post-capture-template))))))
 #+END_SRC

 #+RESULTS:
**** Functions
***** Hugo
#+begin_src elisp
;; Populates only the EXPORT_FILE_NAME property in the inserted headline.
(defun org-hugo-new-subtree-post-capture-template ()
  "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
  (let* ((title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
         (fname (org-hugo-slug title)))
    (mapconcat #'identity
               `(
                 ,(concat "* TODO " title)
                 ":PROPERTIES:"
                 ,(concat ":EXPORT_FILE_NAME: " fname)
                 ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                 ":END:"
                 "%?\n")          ;Place the cursor here finally
               "\n")))
;; (defun org-hugo-new-subtree-post-capture-template ()
;;   "Returns `org-capture' template string for new Hugo post.
;; See `org-capture-templates' for more information."
;;   (let* ((title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
;;          (fname (org-hugo-slug title)))
;;     (mapconcat #'identity
;;                `(
;;                  ,(concat "* TODO " title)
;;                  ":PROPERTIES:"
;;                  ,(concat ":EXPORT_HUGO_BUNDLE: " fname)
;;                  ":EXPORT_FILE_NAME: index"
;;                  ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
;;                  ":END:"
;;                  "%?\n")                ;Place the cursor here finally
;;                "\n")))
#+end_src

***** Ledger
#+begin_src elisp
(defvar my/org-ledger-card-template
  "%(org-read-date) %^{Payee}
       Expenses:%^{Account}  €%^{Amount}
       Liabilities:DebidCard:Mediolanum"
  "Template for devid card transaction with ledger.")

(defvar my/org-ledger-cash-template
  "%(org-read-date) * %^{Payee}
       Expenses:%^{Account}  €%^{Amount}
       Assets:Cash:Wallet"
  "Template for cash transaction with ledger.")
#+end_src

#+RESULTS:
: my/org-ledger-cash-template

*** Code blocks templates
**** Delete unwanted
#+begin_src elisp
(after! org
  (setq org-structure-template-alist (delete '("e" . "example") org-structure-template-alist)
        org-structure-template-alist (delete '("E" . "export") org-structure-template-alist)))
#+end_src

**** Add mines
#+begin_src elisp
(after! org
  (add-to-list 'org-structure-template-alist
               '("e" . "src elisp"))
  (add-to-list 'org-structure-template-alist
               '("E" . "example"))
  (add-to-list 'org-structure-template-alist
               '("b" . "src bash"))
  (add-to-list 'org-structure-template-alist
               '("L" . "LaTeX"))
  ;; Shortcut for "normal" session evaluation with verbatim output:
  (add-to-list 'org-structure-template-alist
               '("jj" . "src ess-julia :results output"))
  (add-to-list 'org-structure-template-alist
               '("j" . "src ess-julia :results output :session *julia* :exports both"))
  ;; Shortcut for inline graphical output within a session:
  (add-to-list 'org-structure-template-alist
               '("jpic" . "src ess-julia :results output graphics file :file FILENAME.png"))
  (add-to-list 'org-structure-template-alist
               '("jvterm" . "src julia-vterm :session"))
  ;; Shortcut for well-formatted org table output within a session:
  (add-to-list 'org-structure-template-alist
               '("jtab" . "src ess-julia :results value table :colnames yes")))
#+end_src

**** Calling
#+begin_src elisp
(defun brust-org< nil
  "Self insert command or expand org-insert-structure-template"
  (interactive)
  (if (or (region-active-p) (looking-back "^"))
      (progn
        (call-interactively 'org-insert-structure-template)
        (insert "\n")
        (backward-char 1))
    (self-insert-command 1)))
#+end_src

*** Pretty headlines
#+begin_src elisp
(after! org
  (font-lock-add-keywords            ;; A bit silly but my headers are now
   'org-mode                         ;; shorter, and that is nice canceled
   (mapcar (lambda (keysymbol)
             `(,(concat "^\\(\\*\\{" (car keysymbol) "\\}\\) ")
               (1
                (progn (compose-region (match-beginning 1) (match-end 1) ,(cdr keysymbol)) nil)
                append)))
           '(("1" . "☰")
             ("2" . "☱")
             ("3" . "☲")
             ("4" . "☳")
             ("5" . "☴")
             ("6" . "☵")
             ("7" . "☶")
             ("8," . "☷")))))
#+end_src
*** ob languages
**** ob-ess-julia
#+begin_src elisp
;; Load ob-ess-julia and dependencies
(use-package! ob-ess-julia
  :after org
  :config
  ;; Add ess-julia into supported languages:
  (add-to-list 'org-babel-load-languages '(ess-julia . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
  ;; (org-babel-do-load-languages 'org-babel-load-languages
  ;;                              (append org-babel-load-languages
  ;;                                      '((ess-julia . t))))
  ;; Link this language to ess-julia-mode (although it should be done by default):
  ;; (setq org-src-lang-modes
  ;;       (append org-src-lang-modes '(("ess-julia" . ess-julia))))
  (setq org-src-lang-modes
        (append org-src-lang-modes '(("ess-julia" . "julia"))))
  )
#+end_src
**** ob-julia-vterm

#+begin_src elisp
;; Load ob-ess-julia and dependencies
(use-package! ob-julia-vterm
  :after (org julia-vterm)
  :config
  ;; Add ess-julia into supported languages:
  (add-to-list 'org-babel-load-languages '(julia-vterm . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
  (add-to-list 'org-babel-tangle-lang-exts '("julia-vterm" . "jl"))
  ;; (org-babel-do-load-languages 'org-babel-load-languages
  ;;                              (append org-babel-load-languages
  ;;                                      '((ess-julia . t))))
  ;; Link this language to ess-julia-mode (although it should be done by default):
  ;; (setq org-src-lang-modes
  ;;       (append org-src-lang-modes '(("ess-julia" . ess-julia))))
  )
#+end_src

*** COMMENT Pdf links org-pdftools
     Org links for pdfs
#+begin_src elisp
  (use-package org-pdfview
    :config ;;(setq org-pdftools-root-dir "~/Dropbox/bibliography/pdf")
    )
#+end_src

#+RESULTS:

*** COMMENT Ledgers
    Mainly from [[https://www.reddit.com/r/emacs/comments/8x4xtt/tip_how_i_use_ledger_to_track_my_money/][Reddit discution]]
**** Config
#+BEGIN_SRC elisp
  (use-package! ledger-mode
    :mode ("\\.dat\\'"
           "\\.ledger\\'")
    :custom
    (ledger-clear-whole-transactions t)
    (add-hook 'ledger-mode-hook #'ledger-flymake-enable)
    (add-hook 'ledger-mode-hook #'company-mode)
    (ledger-post-auto-adjust-amounts t)
    :bind
    (:map ledger-mode-map
          ("C-c C-a" . brust-ledger-add-transaction)))

  (with-eval-after-load 'ledger-mode
    (define-key ledger-mode-map [remap save-buffer] #'std::ledger::save))
#+END_SRC

#+RESULTS:
: std::ledger::save

**** Functions
#+BEGIN_SRC elisp
  (defun brust-ledger-add-transaction (&optional -date)
    "Add new transaction using `org-read-date'"
    (interactive)
    (ledger-add-transaction
     (or -date (org-read-date))
     nil)
    (insert "?\n    Assets:DebitCard")
    (cdlatex-position-cursor))

  (defun std::ledger::save nil
    "First `ledger-mode-clean-buffer', then `save-buffer'."
    (interactive)
    (save-excursion
      (when (buffer-modified-p)
        (with-demoted-errors (ledger-mode-clean-buffer))
        (save-buffer))))

  (defun brust-ledger-copy-transaction-from-extract nil
    "`-string' is a line of my bank extract in cvs format"
    (interactive)
    (let ((-entry
           (split-string
            (buffer-substring-no-properties (point-at-bol) (point-at-eol))
            "\,")))
      (switch-to-buffer "ledger-2021.dat")
      (brust-ledger-add-transaction
       (brust-from-eur-ame-date (nth 0 -entry)))
      (insert (capitalize (nth 1 -entry))
              "\n    ?  €"
              (nth 3 -entry))
      (cdlatex-position-cursor)))


  (defun brust-from-eur-ame-date (-date)
    (let ((-new-date (split-string -date "/")))
      (concat (nth 2 -new-date)
              "-"
              (nth 1 -new-date)
              "-"
              (nth 0 -new-date))))
#+END_SRC

#+RESULTS:
: std::ledger::save
** LaTeX mode
*** AUCTeX
#+BEGIN_SRC elisp
;; Add hooks and some basic variables declations
(brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "init" t)

;; + variables has to be declared before loading module
(setq +latex-bibtex-file "~/Dropbox/bibliography/my.bib"
      +latex-viewers '(pdf-tools))

(after! latex
  ;; File types
  (add-to-list 'auto-mode-alist '("\\.sty\\'"  . LaTeX-mode))

  ;; Doom stuff
  (remove-hook 'TeX-mode-hook #'TeX-fold-mode)
  ;; Settings
  ;; Config options
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "config" t)
  ;; Add C-c C-q for clean and indent
  ;; (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "LaTeX-extra" t)
  )
#+END_SRC

#+RESULTS:

*** RefTeX
Add interactive TOC and references manager at .tex files.
#+begin_src elisp
(after! (latex reftex)
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "RefTeX" t)

  (add-hook! 'reftex-select-label-mode-hook
    (map! :map reftex-select-label-mode-map
          :e "j"  #'reftex-select-next
          :e "k"  #'reftex-select-previous))

  (add-hook! 'reftex-toc-mode-hook
    (map! :map 'local
          :e "1"  #'brust-reftex-toc-level-1
          :e "2"  #'brust-reftex-toc-level-2
          :e "3"  #'brust-reftex-toc-level-3
          :e "4"  #'brust-reftex-toc-level-4
          :e "5"  #'brust-reftex-toc-level-5
          :e "6"  #'brust-reftex-toc-level-6
          :e "m"  #'describe-mode
          )))
#+end_src

*** CDLaTeX
#+begin_src elisp
(after! (latex cdlatex)
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-latex-config.org" "cdLaTeX" t))
#+end_src
*** Bratex
    Load before auctex ??2
#+BEGIN_SRC elisp
(use-package! bratex
  :after latex)
#+END_SRC

#+RESULTS:
: bratex-config
*** Bindings
#+begin_src elisp
(map! :after latex
      (:map LaTeX-mode-map
       :gin "]"    #'brust-LaTeX-insert-math1
       :gin "}"    #'brust-LaTeX-insert-math2
       ;; "C-c C-q"   #'latex/clean-fill-indent-environment ;; Now use "= G"
       "s-e"       #'brust-LaTeX-next-error
       "s-t"       #'TeX-complete-symbol ;; Auto-complete funcion of AUCTeX
       "C-c C-e"   #'brust-LaTeX-env
       "<M-up>"    #'bratex-cycle-size
       "<M-down>"  #'bratex-cycle-size-reverse
       "<M-right>" #'bratex-cycle-bracket
       "<M-left>"  #'bratex-cycle-bracket-reverse
       (:localleader
        "5" #'latex-replace-in-math
        "%" #'latex-replace-regexp-in-math
        "0" #'brust-cycle-texmath
        "W" #'brust-wc-save-words
        "r" #'reftex-reference
        "t" #'reftex-toc
        "b" #'reftex-citation
        "e" #'brust-LaTeX-set-header
        "SPC" #'TeX-command-master
        "m" #'TeX-insert-macro
        "]" #'LaTeX-close-environment
        "E" #'LaTeX-environment
        "c" #'ivy-bibtex-with-local-bibliography)))

(map! :after (latex cdlatex)
      :map cdlatex-mode-map
      "`" nil
      :i ";"   #'cdlatex-math-symbol
      :i "C-;" (lambda nil (insert ";"))
      :i "TAB" #'cdlatex-tab
      :localleader
      "e" #'cdlatex-environment)
#+end_src

*** COMMENT LSP LaTeX
#+begin_src elisp
;; "texlab" must be located at a directory contained in `exec-path'.
;; If you want to put "texlab" somewhere else,
;; you can specify the path to "texlab" as follows:
(setq lsp-latex-texlab-executable "~/src/texlab-git/target/release/texlab")

(after!
  (require 'lsp-latex)
  (add-hook 'tex-mode-hook 'lsp)
  (add-hook 'latex-mode-hook 'lsp))
#+end_src
** TODO Bibliography
*** BibTeX
#+begin_src elisp
(after! (latex bibtex)
  (add-to-list 'auto-mode-alist '("\\.bib\\'"  . bibtex-mode))
  (setq bibtex-maintain-sorted-entries t ;; to sort bibtex entries with C-c C-c
        bibtex-comma-after-last-field t ;; coma is inserted after last field
        bibtex-entry-format
        (append '(whitespace
                  realign
                  unify-case
                  last-comma
                  sort-fields)
                (delq! 'required-fields bibtex-entry-format))))
#+end_src
*** Biblio
Getting bibtex entries from crossref and much more.
#+begin_src elisp
(setq biblio-crossref-user-email-address user-mail-address) ;; CrossRef gives priority to queries that include an email address.

;; Use the same shortcut to search bib items on internet for all the engines.
(after! bibtex-completion
  (setq bibtex-completion-fallback-options
        (append
         '(("MathSciNet                                (bibretrive.el)"
            . (lambda (search-expression) (bibretrieve))))
         bibtex-completion-fallback-options)))
#+end_src
**** COMMENT MathSciNet backend
Problem: MathSciNet uses author title... not a "everywhere" query.
The package bibretrive is a mess, but it works.
To unify engines: Added action to "ivy-bibtex" to look for MathSciNet using bibretrive
Once it is done, add the correspnding entrie to =bibtex-completion-fallback-options=
#+begin_src elisp
(defun biblio-crossref-backend (command &optional arg &rest more)
  "A CrossRef backend for biblio.el.
COMMAND, ARG, MORE: See `biblio-backends'."
  (pcase command
    (`name "CrossRef")
    (`prompt "CrossRef query: ")
    (`url (biblio-crossref--url arg))
    (`parse-buffer (biblio-crossref--parse-search-results))
    (`forward-bibtex (biblio-crossref--forward-bibtex arg (car more)))
    (`register (add-to-list 'biblio-backends #'biblio-crossref-backend))))

(defun biblio-msn-backend (command &optional arg &rest more)
  "A MathSciNet backend for biblio.el.
COMMAND, ARG, MORE: See `biblio-backends'."
  (pcase command
    (`name "MathSciNet")
    (`prompt "MathSciNet query: ")
    (`url (biblio-crossref--url arg))
    (`parse-buffer (biblio-crossref--parse-search-results))
    (`forward-bibtex (biblio-crossref--forward-bibtex arg (car more)))
    (`register (add-to-list 'biblio-backends #'biblio-crossref-backend))))


(defun biblio-msn--url (query)
  "Create a MathSciNet url to look up QUERY."
  (let* ((pairs `(("bdlback" . "r=1")
		              ("dr" . "all")
		              ("l" . "20")
		              ("pg3" . "TI")
		              ("s3" . ,title)
		              ("pg4" . "ICN")
		              ("s4" . ,author)
		              ("fn" . "130")
		              ("fmt" . "bibtex")
		              ("bdlall" . "Retrieve+All"))))
	  (url (concat "https://mathscinet.ams.org/mathscinet/search/publications.html?" (mm-url-encode-www-form-urlencoded pairs)))))

(defun biblio-crossref--url (query)
  "Create a CrossRef url to look up QUERY."
  (format "https://api.crossref.org/works?query=%s%s"
          (url-encode-url query)
          (if biblio-crossref-user-email-address
              (format "&mailto=%s" (url-encode-url biblio-crossref-user-email-address)) "")))
#+end_src

*** Bibretrive
Getting bib entries from MathSciNet
#+BEGIN_SRC elisp
;; See https://github.com/pzorin/bibretrieve
(use-package! bibretrieve
  :after latex
  :config
  (setq bibretrieve-prompt-for-bibtex-file nil ;; use defaul bib file
        bibretrieve-backends '(("msn" . 10) ("arxiv" . 5))))
#+END_SRC
*** TODO Sci hub
*** Ivy-bibtex
Insert cite links and open pdf
#+begin_src elisp
(setq bibtex-completion-bibliography "~/Dropbox/bibliography/my.bib"
      bibtex-completion-additional-search-fields '(keywords tags)
      bibtex-completion-pdf-extension '(".pdf" ".djvu")
      ivy-bibtex-default-action 'ivy-bibtex-insert-citation
      bibtex-completion-pdf-field "file" ;; pdf assoc a bib entry by field "file = {/path/to/article.pdf;:/path2...}"
      bibtex-completion-display-formats
      '((t . "${author:25} ${year:4} ${title:*} ${=has-pdf=:1} ${keywords:10} ${=type=:3}")))

;; Show entries in the same order as in bibtex file
(advice-add 'bibtex-completion-candidates
            :filter-return 'reverse)
#+end_src

*** ox-bibtex
Maintaining notes.org
#+begin_src elisp
(after! org
  (require 'ox-bibtex)
  )
#+end_src

** COMMENT Mu4e
*** General info
    - Manual [[https://www.djcbsoftware.nl/code/mu/mu4e/index.html#Top][Mu4e's online manual]]
    - TODOs [0/6]
      - [ ] Install [[https://github.com/iqbalansari/mu4e-alert][mu4e alerts]]
      - [ ] Improve keybinding
      - [ ] Show links
      - [ ] Show images
      - [ ] Check autopudate (related to point one).
      - [ ] Improve contact completion with ivy :) [[http://pragmaticemacs.com/emacs/even-better-email-contact-completion-in-mu4e/]]
    - Helpful places [5/9]
      - [X] [[https://webgefrickel.de/blog/a-modern-mutt-setup][A modern mutt setup with neomutt, mbsync, msmtp and mu]] (blog - interesting not just emacs)
      - [ ] [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-][A Complete Guide to Email in Emacs using Mu and Mu4e]] (blog interesting by itself - really fancy emacs stuff)
      - [ ] [[https://www.djcbsoftware.nl/code/mu/mu4e/Example-configurations.html#Example-configurations][Example config (from mu4e the manual)]]
      - [ ] [[http://xenodium.com/#trying-out-mu4e-and-offlineimap][Albaro]] & [[http://xenodium.com/#trying-out-mu4e-with-mbsync][Albaro2]] (here there are many nice links) (blog - interesting not just emacs).
      - [X] [[https://stackoverflow.com/questions/50199837/mu4e-with-msmtp-does-not-store-mail-sent-directory-after-sending-mails][How to config mu4e to send mail using msmtp]]
      - [X] [[https://blog.programster.org/ubuntu-install-gpg-2][Install gpg2 (much better)]] to encript your mail password (echo password | gpg2 -c) then delete the corresponding line on bash history ;)
      - [ ] [[http://pragmaticemacs.com/mu4e-tutorials/][mu4e tutorials (form pragmatic emacs)]]
      - [X] [[https://wiki.archlinux.org/index.php/msmtp][Archlnux msmpt config page]]
      - [X] [[https://wiki.archlinux.org/index.php/Isync#Troubleshooting][Archlinux mbsync config page]]
      -
*** COMMENT Install
 Just in case to generate a certificate:
 # openssl s_client -connect mail.mat.uab.cat:993 -showcerts 2>&1 < /dev/null | sed -ne '/-BEGIN CERTIFICATE-/,/-END CERTIFICATE-/p' | sed -ne '1,/-END CERTIFICATE-/p' > ~/mail.uab.cat.ctr

 #+BEGIN_SRC bash
   # Install things
   sudo apt install msmtp-gnome msmtp-mta isync gnupg2
   cd src
   git clone https://github.com/djcb/mu.git
   ./autogen.sh
   make

   # Paswords
   ## UAB
   cd
   echo PASSWORD > .mathuab
   gpg2 -c .mathuab
   rm .mathuab
   ## Gmail
   echo PASSWORD > .gmailpass
   gpg2 -c .gmailpass
   rm .gmailpass
   # Delete corresponding lines of .bash_history

   mkdir Maildir
   # Copy from Dropbox/config/Maildir
 #+END_SRC

 #+RESULTS:
*** Add Path
 #+BEGIN_SRC elisp
(add-to-list 'load-path (expand-file-name "~/src/mu/mu4e/"))
 #+END_SRC

 #+RESULTS:
*** Config
[[file:lisp/brusts-mu4e-config.org][Mu4e config file]]
#+begin_src elisp
(use-package! mu4e
  :commands (mu4e)
  :config
  ;; The setq's
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Basic" t)

  ;; My contexts
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Contexts" t)

  ;; Actions
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Actions" t)

  ;; My Main menu
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Main Menu" t)

  ;; Marking emails for new actions
  (brust-endless/org-eval-eblocks "~/.doom.d/local/lisp/brusts-mu4e-config.org" "Marks" t)
  (map! (:map mu4e-headers-mode-map
         "g" #'mu4e-headers-mark-for-tag
         "A" #'mu4e-headers-mark-for-moveUAB)
        (:map mu4e-view-mode-map
         "g" #'mu4e-headers-mark-for-tag
         "A" #'mu4e-headers-mark-for-moveUAB))

  ;; Fixing 'evil-collection-mu4e', see update in https://github.com/emacs-evil/evil-collection/issues/309
  (defun brust-workaround-fixing-evil-collection-mu4e nil
    (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view))
  (remove-hook 'mu4e-main-mode-hook 'evil-collection-mu4e-update-main-view)
  (advice-add 'evil-collection-mu4e-setup :after #'brust-workaround-fixing-evil-collection-mu4e)

  (map! :map mu4e-headers-mode-map
        ;; "." #'hydra-mu4e-headers/body ; This hydra is for headers mode
        "o" #'my/org-capture-mu4e                 ; differs from built-in
        "A" #'mu4e-headers-mark-for-action        ; differs from built-in
        "|" #'mu4e-view-pipe                         ; does not seem to be built in any longer
        ))
#+end_src

#+RESULTS:
: t
** Programming
*** Julia mode
**** Intro
julia-mode is just for editing .jl files (every other julia related mode uses it for this propose).

ESS julia provides ESS[julia] mode to edit .jl files, which uses julia-mode for syntaxis.
It also provides an interaction with Julia REPL, but with limited functionality:
Starts a julia process whose output is print in a buffer, but the buffer is not a terminal.
Problems:
  - Polymake does not load (I do not know the reason)
  - It has no colors
  - The functionalities ; ] of julia does not work and ? works but prompt does not changes.
    see[[https://github.com/emacs-ess/ESS/issues/143][Terminal not fully functional]]
Good things
  - It creates a backend for company (it requires to start the julia process)
  - The backend (sometimes?) even incorporates user defined variables!
  - Full integration with Doom emacs (eval region/line... under localleader key)

julia-repl is another way to communicate with julia.
It creates a julia process running in a term terminal in Emacs.
Good
  - Polymake load
  - has colors
  - has the functionalities ; ] ? and the prompt changes.
Bad
  - zero integration with company
  - zero integration with Doom emacs
    see [[https://github.com/tpapp/julia-repl/issues/81][problem with executable]]
**** Julia repl mode
#+begin_src elisp
;; (require 'julia-mode)
;; (require 'julia-repl)
;; (add-hook 'julia-mode-hook 'julia-repl-mode) ;; always use minor mode
(setq julia-repl-executable-records
      `(;; (default "julia")
        (master ,(expand-file-name (concat "~/src/julia/"
                                           (if (member "bin" (directory-files "~/src/julia"))
                                               "bin/")
                                           "julia"))))) ; in the executable path
;; (setq
;;  term-char-mode-buffer-read-only nil
;;  term-char-mode-point-at-process-mark nil)

;; (after! julia-mode
;;   (add-hook 'julia-mode-hook #'julia-vterm-mode)
;;   (remove-hook 'julia-mode-hook #'julia-repl-mode))

(after! julia-repl
  (julia-repl-set-terminal-backend 'vterm)
  ;; (add-hook 'term-mode-hook #'visual-line-mode)
  (setq auto-mode-alist (delete '("\\.jl\\'" . ess-julia-mode) auto-mode-alist))
  ;; treat underscores as word delimiters, see https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-do-i-get-motions-to-treat-underscores-as-word-delimiters
  (add-hook! 'julia-mode-hook (modify-syntax-entry ?_ "w"))

  ;; (add-hook! 'julia-repl-hook (julia-repl--send-string (concat "include(\"" (expand-file-name "~/.julia/config/startup.jl") "\")")))
  ;; It cause a problem, execute julia-repl--send-string in this hook (outside hook there is no problem, not realted to doom, emacs -q and install julia-repl reproduce it) Actually, not needed, now julia-repl loads startup.jl
  (map! (:map julia-repl-mode-map
         (:localleader
          :desc "line or region"      "SPC" #'julia-repl-send-region-or-line
          :desc "Start process"       "o" #'+julia/open-repl
          :desc "Start eglot server"  "." #'+lsp!
          :desc "Set dir to buffer's" "d" #'julia-repl-cd
          :desc "Doc symbol"          "h" #'julia-repl-doc
          :desc "Call \\@edit"        "e" #'julia-repl-edit
          :desc "Send buffer"         "b" #'julia-repl-send-buffer
          :desc "Generate exports"    "x" #'brust-julia-update-exports
          :desc "Methods symbol"      "m" #'julia-repl-list-methods))
        (:map term-raw-map
         "C-RET" #'brust-julia-close-send-line
         (:desc "BMO local" :prefix "C-c l"
          :desc "Clear buffer" "d" #'comint-clear-buffer
          :desc "Send typeof"  "t" #'brust-julia-send-typeof
          :desc "Send eltype"  "e" #'brust-julia-send-eltype
          :desc "Send size"    "s" #'brust-julia-send-size
          :desc "Close and send line" "c" #'brust-julia-close-send-line))))
#+end_src

#+RESULTS:
**** eglot-jl
#+begin_src elisp
(after! eglot
  (setq eglot-connect-timeout (* 60 2)
        ;; To use my LanguageServer and Symbols...
        eglot-jl-language-server-project "~/.julia/environments/v1.6"
        ;; To use eglot's LanguageServer and Symbols... (ther is no way to make it work)
        ;; eglot-jl-language-server-project eglot-jl-base
        ))
#+end_src
**** ad-hoc functions
***** generic
#+begin_src elisp
(defun brust--julia-input-bounds nil
  (save-excursion
    (move-beginning-of-line 1)
    (search-forward "> " (point-at-eol) t)
    ;; (message "  Input bounds are %i %i"
    ;;          (car (cons (point) (point-at-eol)))
    ;;          (cdr (cons (point) (point-at-eol))))
    (cons (point) (point-at-eol))))

(defun brust--julia-input-string nil
  (let* ((-bounds (brust--julia-input-bounds))
         (-str (buffer-substring (car -bounds) (cdr -bounds))))
    ;; (message "  Input string is \"%s\"" -str)
    -str))

(defun brust--julia-input-delete nil
  (let* ((-bounds (brust--julia-input-bounds))
         (N (- (cdr -bounds) (car -bounds))))
    (dotimes (i N) (term-send-left))
    (dotimes (i N) (term-send-del))))

;; (defun singpolyma/term-insert-literal (key)
;;     "Take a keypress and insert it literally into a terminal."
;;     (interactive "cPress key:")
;;     (message "%s" (format "%c" key))
;;     )
#+end_src

#+RESULTS:
: brust--julia-input-delete

***** Send common functions
#+begin_src elisp
(defun brust-julia--add-function (-fun)
  ;; (move-end-of-line 1)
  ;; (dotimes (i (point-at-eol) (point)) (term-send-right))
  (let ((input (brust--julia-input-string)))
    (brust--julia-input-delete)
    (julia-repl--send-string (concat -fun "(" input ")"))))

(defun brust-julia-send-typeof nil
  (interactive)
  (brust-julia--add-function "typeof"))

(defun brust-julia-send-eltype nil
  (interactive)
  (brust-julia--add-function "eltype"))

(defun brust-julia-send-size nil
  (interactive)
  (brust-julia--add-function "size"))
#+end_src

#+RESULTS:
: brust-julia-send-eltype

***** Close line
#+begin_src elisp
(defun brust-julia-close-send-line nil
  (interactive)
  (let ((input (brust--julia-input-string)))
    (if (string= input "")
        (term-send-raw)
      (brust--julia-input-delete)
      (julia-repl--send-string
       (with-temp-buffer
         (insert input)
         (goto-char (point-max))
         (close-all-open-paren-right)
         (buffer-string))))))
#+end_src

#+RESULTS:
: brust-julia-close-send-line
***** Generate 'exports'
#+begin_src elisp
(defun brust-julia-update-exports nil
  (interactive)
  (save-excursion
    (let ((defunlist (brust-julia--collect-defuns)))
      (goto-char (point-min))
      (insert "\nexport\n")
      (while (< 1 (length defunlist))
        (insert (car (pop defunlist)) ",\n"))
      (insert (car (pop defunlist)) "\n"))))

(defun brust-julia--collect-defuns nil
  (goto-char (point-max))
  (let ((defunlist '()))
    (while (julia-beginning-of-defun)
      (if (string= (thing-at-point 'word t) "function") (forward-word 2))
      (pushnew! defunlist (julia-repl--symbols-at-point))
      (move-beginning-of-line 1))
    defunlist))
#+end_src

*** Maple
#+begin_src elisp
;; (add-load-path! "~/src/maplev-master/lisp")
(autoload 'maplev-mode "maplev" "Maple editing mode" 'interactive)
(add-to-list 'auto-mode-alist '("\\.mpl\\'" . maplev-mode))
#+end_src

*** POV-Ray
#+begin_src elisp
(defun brust-pov-ray-compile nil
  (interactive)
  (save-buffer)
  (pov-menu-render-highest))

(map! :localleader
      :map pov-mode-map
      "SPC" #'brust-pov-ray-compile
      "q" #'pov-command-query ;AS
      "h" #'pov-keyword-help
      "r" #'pov-tool-bar-command-render
      "l" #'pov-show-render-output
      "1" #'pov-menu-render-test
      "2" #'pov-menu-render-low
      "3" #'pov-menu-render-mid
      "4" #'pov-menu-render-high
      "5" #'pov-menu-render-highest
      "i" #'pov-open-include-file
      "e" #'pov-menu-external-viewer
      "v" #'pov-menu-internal-viewer
      )
#+end_src

#+RESULTS:
: brust-pov-ray-compile

*** TODO Singular
**** Config
#+BEGIN_SRC elisp
(setq singular-emacs-home-directory "/usr/share/singular/emacs/")
;; (add-load-path! singular-emacs-home-directory)
(cl-pushnew singular-emacs-home-directory load-path :test #'string=)
(autoload 'singular "singular"
  "Start Singular using default values." t)
(autoload 'singular-other "singular"
  "Ask for arguments and start Singular." t)

(add-to-list 'auto-mode-alist '("\\.sing\\'" . c++-mode))
(add-to-list 'auto-mode-alist '("\\.lib\\'" .  c++-mode))

(defun brust-singular-mode-hook nil
  ;; turn-on fontification for c++-mode
  (font-lock-mode 1)
  (set (make-local-variable 'singular-commands-alist) nil)
  (load (concat singular-emacs-home-directory "cmd-cmpl"))
  ;; turn on aut-new line
  (c-toggle-auto-newline 1)
  ;; tunr off hungry-delete
  (c-toggle-hungry-state -1)
  (company-mode -1))

(add-hook 'c++-mode-hook #'brust-singular-mode-hook)

(defun brust-singular-intetractive-mode nil
  (brust-math-software-hookfun-to-intangify-prompt)
  (hl-line-mode 1))

(add-hook 'singular-interactive-mode-hook #'brust-singular-intetractive-mode)

(defadvice singular-send-or-copy-input (before finish-line activate)
  (brust-singular-finish-line-interaction-mode))

#+END_SRC

#+RESULTS:
: singular-send-or-copy-input
**** Maps
#+begin_src elisp
(map! (:map c++-mode-map
       "C-<return>" #'newline
       "<return>" #'brust-singular-finish-line-singular-edit-mode
       (:localleader
        "<tab>" #'brust-singular-dynamic-complete
        "a"   #'singular-beginning-of-line
        "p"   #'brust-singular-add-print
        "s"   #'brust-singular-add-std
        "SPC" #'brust-singular-eval-region-or-line
        ";" #'comment-region
        "b" #'brust-singular-eval-buffer
        "s" #'brust-singular-fixed-region-set-region
        "f" #'brust-singular-fixed-region-eval
        "e" #'brust-singular-eval-proc))
      (:map singular-interactive-mode-map
       "C-p" #'brust-singular-add-print
       "C-s" #'brust-singular-add-std))
#+end_src

**** function to send the working file.
#+BEGIN_SRC elisp

(defvar brust-singular-fixed-region-poss nil "Cons of positions delimiting the fixed region")

(defun brust-singular-fixed-region-set-region (args)
  (interactive "P")
  (unless (use-region-p) (user-error "Region has to be activate"))
  (let ((beg (region-beginning))
        (end (region-end)))
    (setq brust-singular-fixed-region-poss (cons beg end))
    (message "Fixed-region seted from line %d to %d"
             (line-number-at-pos beg)
             (line-number-at-pos end)))
  (deactivate-mark t))

(defun brust-singular-fixed-region-eval (args)
  (interactive "P")
  (message "Evaluated region (%d:%d) in [[%s]]"
           (line-number-at-pos (car brust-singular-fixed-region-poss))
           (line-number-at-pos (cdr brust-singular-fixed-region-poss))
           buffer-file-name)
  (brust-singular--eval-string
   (buffer-substring-no-properties
    (car brust-singular-fixed-region-poss)
    (cdr brust-singular-fixed-region-poss))
   args))

(defun brust-singular-eval-region-or-line (args)
  (interactive "P")
  (let (-str)
    (if (not (use-region-p))
        (save-excursion
          (while (not (or (brust-singular--ending-semicolon-p) (bobp)))
            (forward-line -1))
          (setq -str (thing-at-point 'line t))
          (unless (brust-singular--ending-semicolon-p -str)
            (user-error "There is no line to eval"))
          (unless (brust-singular--check-parents -str)
            (user-error "Unbalanced Parents!!!"))
          (message "Evaluated line (%d) in [[ %s ]]"
                   (line-number-at-pos (point))
                   (buffer-name)))
      (message "Evaluated region between lines (%d:%d) in [[ %s ]]"
               (line-number-at-pos (region-beginning))
               (line-number-at-pos (region-end))
               (buffer-name))
      (setq -str (buffer-substring-no-properties
                  (region-beginning) (region-end))))
    (brust-singular--eval-string -str args)))

(defun brust-singular--ending-semicolon-p (&optional -string)
  (unless -string
    (setq -string (thing-at-point 'line t)))
  (string= ";"
           (substring (s-trim
                       (car
                        (split-string
                         -string "//")))
                      -1)))

(defun brust-singular--check-parents (&optional -string)
  (unless -string
    (setq -string (thing-at-point 'line t)))
  (with-temp-buffer
    (insert -string)
    (ignore-errors (check-parens) t)))

(defun brust-singular--eval-string (-str &optional args)
  (save-window-excursion
    (singular)
    (goto-char (point-max))
    (let ((process (singular-process))
          (--str (concat (s-trim -str)
                         (unless (string= (substring -str -1) ";")
                           "\n;"))))
      (when args (singular-control-c 'restart))
      (singular-input-filter process --str)
      (singular-send-string process --str))))

(defun brust-singular--delete-comments (&optional -string)
  (unless -string
    (setq -string (thing-at-point 'line t)))
  (with-temp-buffer
    (insert -string)
    (goto-char (point-min))
    (while (search-forward "//" nil t)
      (forward-char -2)
      (delete-region (point) (line-end-position)))
    (buffer-string)))

(defun brust-singular-eval-proc (args)
  "Eval last proc declaration."
  (interactive "P")
  (save-excursion
    (search-backward "proc" nil t)
    (let ((-beg (point))
          (-name
           (if (re-search-forward "[ \s\t]+" (line-end-position) t)
               (let ((-beg2 (point)))
                 (if (search-forward "(" (line-end-position) t)
                     (s-trim (buffer-substring-no-properties -beg2 (1- (point))))
                   nil))
             nil)))
      (search-forward "{" nil t)
      (forward-char -1)
      (sp-forward-sexp)
      (brust-singular--eval-string
       (buffer-substring-no-properties -beg (point))
       args)
      (if -name
          (message "Evaluated proc {{%s}}, between lines (%d:%d), in file [[%s]]"
                   -name
                   (line-number-at-pos -beg)
                   (line-number-at-pos (point))
                   (file-name-base (buffer-name)))
        (message "Evaluated proc between lines (%d:%d) and file [[%s]] (Warring:: its name is not on the definition line)"
                 (line-number-at-pos -beg)
                 (line-number-at-pos (point))
                 (file-name-base (buffer-name)))))))

;;(defun brust-singular-eval-buffer-line-by-line nil
;;  (interactive)
;;  (let ((-total-str (buffer-string))
;;        (-base-name (file-name-base (buffer-name))))
;;    (with-temp-buffer
;;      (insert -total-str)
;;      (brust-singular--delete-comments)
;;      (goto-char (point-min))
;;      (while (not (eobp))
;;        ;;(or (brust-check-line-parents) (user-error "Unbalanced Parent!!!"))
;;        (let ((-str (s-trim (buffer-substring-no-properties
;;                             (line-beginning-position)
;;                             (line-end-position))))
;;              (-line (line-number-at-pos)))
;;          (unless
;;              (cond ((string= -str "") t)
;;                    ((string= (substring -str -1) ";")
;;                     (brust-singular--eval-string
;;                      -str
;;                      (format "line:%d:of::%s--" -line -base-name)
;;                      nil)
;;                     t)
;;                    (t (brust-singular-eval-environment args) t))
;;            (message "Error on line:%d (%s)" -line -str)
;;            (goto-char (point-max)))
;;          ;;(when err (goto-char err))
;;          (forward-line 1))))))

;;(defun brust-singular--temp-file (-str -name)
;;  (let ((-temp-file
;;         (make-temp-file
;;          (replace-regexp-in-string "[.]" "-" -name)
;;          nil ".sing")))
;;    (with-temp-buffer
;;      (insert -str)
;;      (append-to-file (point-min) (point-max) -temp-file))
;;    -temp-file))
#+END_SRC

#+RESULTS:
: brust-singular-eval-proc

**** functions for *singular*
***** Add print std...
#+BEGIN_SRC elisp
(defun brust-singular-add-print nil
  (interactive)
  (brust-singular-add-function "print"))

(defun brust-singular-add-std nil
  (interactive)
  (brust-singular-add-function "std"))

(defun brust-singular-add-function (-fun)
  (let* ((-bounds (if (region-active-p)
                      `(,(region-beginning) . ,(region-end))
                    (save-excursion
                      (move-beginning-of-line 1)
                      (search-forward "> " (point-at-eol) t)
                      `(,(point) . ,(progn
                                      (move-end-of-line 1)
                                      (search-backward ";" (point-at-bol) t)
                                      (point))))))
         (-str (buffer-substring-no-properties (car -bounds) (cdr -bounds))))
    (goto-char (car -bounds))
    (delete-region (car -bounds) (cdr -bounds))
    (insert -fun "(" -str ")")
    (move-end-of-line 1)
    (insert ";")))
#+END_SRC

#+RESULTS:
: brust-singular-finish-line
***** Finish line
#+BEGIN_SRC elisp
(defun brust-singular-finish-line-singular-edit-mode nil
  (interactive)
  (if (or (bolp) (eobp)) (insert "\n")
    (move-end-of-line 1)
    (when (search-backward "//" (point-at-bol) t)
      (skip-chars-backward "[:space:]"))
    (let ((-main-line (s-trim-right
                       (buffer-substring-no-properties (point-at-bol) (point))))
          (-comment-line (buffer-substring-no-properties (point) (point-at-eol))))
      (delete-region (point-at-bol) (point-at-eol))
      (if (or (< (length -main-line) 1))
          (insert (concat -comment-line "\n"))
        (insert
         (concat ;;compare (insert (concat nil "hello")) vs (insert nil "hello")
          (with-temp-buffer ;; To close-all-open-paren-r just of this line and do not use narrow
            (insert (concat -main-line
                            (unless (string= (substring -main-line -1) ";")
                              ";")))
            (forward-char -1)
            (close-all-open-paren-right)
            (buffer-string))
          -comment-line
          "\n"))))))

(defun brust-singular-finish-line-interaction-mode nil
  (interactive)
  (narrow-to-region (point-at-bol) (point-at-eol))
  (move-end-of-line 1)
  (delete-horizontal-space)
  (unless (string= (string (char-before (point))) ";")
    (insert ";"))
  (forward-char -1)
  (close-all-open-paren-right)
  (widen))

#+END_SRC

#+RESULTS:
: brust-singular-finish-line-interaction-mode

***** Dynamic expand in non-running Singular buffer
#+BEGIN_SRC elisp
(defun brust-singular-dynamic-complete ()
  "Dynamic complete word before point.
      Performs completion of Singular commands."
  (interactive)
  (let* ((end (point))
         (beg
          (save-excursion
            (skip-chars-backward "a-zA-Z0-9")
            (point)))
         (str (buffer-substring-no-properties beg end)))
    (if (string= str "")
        (indent-region (point-at-bol) (point-at-eol))
      ;; (call-interactively 'indent-region)
      (if singular-commands-alist
          (singular-completion-do str beg end singular-commands-alist)
        (message "Completion of Singular commands disabled.")
        (ding)))))
#+END_SRC

#+RESULTS:
: brust-singular-dynamic-complete
*** Macaulay2 M2
**** Config.
#+begin_src elisp
;; Setup M2.el for autoloading
;; add "/usr/share/info" to Info-default-directory-list if it isn't there (it is already there)
;; (add-to-list 'Info-default-directory-list "/usr/share/info")
;; (add-load-path! "/usr/share/emacs/site-lisp/Macaulay2/")
(cl-pushnew  "/usr/share/emacs/site-lisp/Macaulay2/" load-path :test #'string=)

(autoload 'M2             "M2" "Run Macaulay2 in an emacs buffer" t)
(autoload 'M2-mode        "M2" "Macaulay2 editing mode" t)
(autoload 'm2-mode        "M2" "Macaulay2 editing mode, name in lower case" t)
(autoload 'm2-comint-mode "M2" "Macaulay2 command interpreter mode, name in lower case" t)
(add-to-list 'auto-mode-alist '("\\.m2\\'" . M2-mode))

;; Uncomment these lines to enable syntax highlighting for the interpreter language
;;(autoload 'D-mode "D-mode" "Editing mode for the interpreter language" t)
;;(add-to-list 'auto-mode-alist '("\\.dd?\\'" . D-mode))
#+end_src

#+RESULTS:
: brust-M2-indent-buffer
**** Map
#+begin_src elisp
(map! (:map M2-mode-map
       :n "= Q" #'brust-M2-indent-buffer
       (:localleader
        "SPC" #'brust-M2-M2-or-M2-send-to-program
        "Q" #'brust-M2-indent-buffer)))
#+end_src

#+RESULTS:

**** Indent buffer
#+begin_src elisp
(defun brust-M2-electric-tab-inerit-indentation nil
  (let ((context (delete-white-space)))
    (M2-electric-tab)
    (when (string-match-p "\n" context) (insert context))))

(defun brust-M2-indent-buffer nil
  (interactive)
  (brust-buffer-advice-line-by-line 'brust-M2-electric-tab-inerit-indentation))
#+end_src
**** M2 or send line
#+begin_src elisp
(defun brust-M2-M2-or-M2-send-to-program nil
  (interactive)
  (if (get-buffer "*M2*")
      (call-interactively 'M2-send-to-program)
    (call-interactively 'M2)))
#+end_src

** Build-in modes
*** Abbrev's
**** Setting
#+BEGIN_SRC elisp
  (setq pre-abbrev-expand-hook (quote (ignore))
        abbrev-file-name "~/Dropbox/config/abbrev-def.el"
        save-abbrevs 'silently)

  (setq-default abbrev-mode t)

  (quietly-read-abbrev-file)
#+END_SRC

#+RESULTS:

**** COMMENT Endless ispell & abbrev
     It comes from [[http://endlessparentheses.com/ispell-and-abbrev-the-perfect-auto-correct.html][Ispell and abbrev]], to find the misspelled work plain =ispell= is used, I adapted it to use =flyspell=, now I just get words which are underlined as misspelled (red curvi line under the word).
     That's useful in TeX files where plain ispell has many false misspellings, but it could be a problem on buffers without =flyspell= minormode.
#+BEGIN_SRC elisp
  (defun endless/simple-get-word ()
    (car-safe (save-excursion (ispell-get-word nil))))

  (defun endless/ispell-word-then-abbrev (p)
    "Call `ispell-word', then create an abbrev for it.
  With prefix P, create local abbrev. Otherwise it will
  be global.
  If there's nothing wrong with the word at point, keep
  looking for a typo until the beginning of buffer. You can
  skip typos you don't want to fix with `SPC', and you can
  abort completely with `C-g'."
    (interactive "P")

    (let ((top (window-start))
          (bot (window-end))
          (position (point))
          incorrect-word-pos
          position-at-incorrect-word
          bef aft)
      (save-excursion
        (save-restriction
          ;; make sure that word under point is checked first
          (forward-word)

          ;; narrow the region
          (narrow-to-region top bot)
          (overlay-recenter (point))

          (let ((overlay-list (overlays-in (point-min) (+ position 1)))
                (overlay 'dummy-value))

            (while overlay
              (setq overlay (car-safe overlay-list))
              (setq overlay-list (cdr-safe overlay-list))
              (when (and overlay
                         (flyspell-overlay-p overlay))
                (setq incorrect-word-pos (overlay-start overlay))

                ;; try to correct word
                (save-excursion
                  (goto-char incorrect-word-pos)
                  (setq bef (endless/simple-get-word))
                  ;; `flyspell-correct-at-point' returns t when there is
                  ;; nothing to correct. In such case we just skip current word.
                  (unless (flyspell-correct-at-point)
                    (setq overlay nil)
                    (setq aft (endless/simple-get-word)))))))))
      (if (and aft bef (not (equal aft bef)))
          (let ((aft (downcase aft))
                (bef (downcase bef)))
            (define-abbrev
              (if p local-abbrev-table global-abbrev-table)
              bef aft)
            (message "\"%s\" now expands to \"%s\" %sally"
                     bef aft (if p "loc" "glob")))
        (user-error "No typo at or before point"))))
#+END_SRC

#+RESULTS:
: endless/ispell-word-then-abbrev

*** Auto revert
    I need this to work with Git and branching.
    Auto refresh all buffers when files have changed on disk.
#+BEGIN_SRC elisp
(setq global-auto-revert-ignore-modes (quote (PDFView))
      auto-revert-check-vc-info t)

(add-hook! 'emacs-startup-hook (global-auto-revert-mode +1))
#+END_SRC

*** Ediff
   The default Ediff behavior is confusing and not desirable. This fixes it.
#+BEGIN_SRC elisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
#+END_SRC

   Make it compatible with =org-mode=
#+BEGIN_SRC elisp
(defun ora-ediff-prepare-buffer nil
  (when (memq major-mode '(org-mode emacs-lisp-mode))
    (outline-show-all)))
#+END_SRC

#+BEGIN_SRC elisp
  (defun ediff-copy-both-to-C nil
    (interactive)
    (ediff-copy-diff
     ediff-current-difference nil 'C nil
     (concat
      (ediff-get-region-contents
       ediff-current-difference 'A ediff-control-buffer)
      (ediff-get-region-contents
       ediff-current-difference 'B ediff-control-buffer))))

  (defun add-d-to-ediff-mode-map nil
    (define-key ediff-mode-map "d" #'ediff-copy-both-to-C))
#+END_SRC

#+begin_src elisp
(after! ediff
  (add-hook 'ediff-keymap-setup-hook #'add-d-to-ediff-mode-map)
  (add-hook 'ediff-prepare-buffer-hook 'ora-ediff-prepare-buffer))
#+end_src
*** Tramp
#+begin_src elisp
(setq password-cache-expiry nil
      remote-file-name-inhibit-cache nil
      tramp-completion-reread-directory-timeout nil
      auth-source-cache-expiry nil
      tramp-ssh-controlmaster-options "" ;; See https://www.reddit.com/r/emacs/comments/fgl6gu/emacs_tramp_tricks/ and https://puppet.com/blog/speed-up-ssh-by-reusing-connections/
      tramp-verbose 1
      vc-ignore-dir-regexp
      (format "\\(%s\\)\\|\\(%s\\)"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))

(defun brust-decrypt (file)
  (when (file-exists-p file)
    (let ((-temp-file (make-temp-file (file-name-base file))))
      (epa-decrypt-file file -temp-file)
      (delete-file -temp-file))))

;; (add-hook! 'after-init-hook (brust-decrypt "~/.authinfo.gpg"))
#+end_src

#+RESULTS:
: brust-decrypt

** External modes
*** Avy
#+begin_src elisp
(setq avy-flyspell-correct-function #'+spell/correct)
#+end_src

#+RESULTS:
: +spell/correct

*** Company
#+BEGIN_SRC elisp
(map! :after company
      :map company-active-map
      "TAB"    #'brust-company-abort-cdlatex-or-yas
      "<tab>"  #'brust-company-abort-cdlatex-or-yas
      "M-o"    #'counsel-company
      "<left>" #'company-complete-common
      "<right>" #'brust-company-insert-selection
      "C-j"    #'company-next-page
      "C-k"    #'company-previous-page
      "C-l"    #'company-show-location
      )

(defun brust-company-abort-cdlatex-or-yas nil
  (interactive)
  (company-abort)
  (cond ((fboundp 'cdlatex-tab) (cdlatex-tab))
        ((fboundp 'yas-expand) (yas-expand))))

(defun brust-company-insert-selection nil
  "Insert the selected candidate and continue company."
  (interactive)
  (when (and (company-manual-begin) company-selection)
    (let ((result (nth company-selection company-candidates)))
      (company--insert-candidate result))))
#+END_SRC
*** Evil mode
**** Settings
#+BEGIN_SRC elisp
(setq evil-cross-lines t
      ;; Use both =jk= and =kj= to esc insert mode
      ;; (equivalent to key-chords jk kj) Press them as single key!
      evil-escape-unordered-key-sequence t
      evil-split-window-below t
      ;; pasting in visual state NOT adds the replaced text to the kill ring
      evil-kill-on-visual-paste nil
      ;; cursor is allowed to move one character past the end of the line
      evil-move-beyond-eol t
      evil-vsplit-window-right t)
(global-evil-visualstar-mode)
#+END_SRC

#+RESULTS:
: t
**** Del char
Do not add single deleted chars to =kill-ring=
[[https://github.com/syl20bnr/spacemacs/issues/6977]]
#+begin_src elisp
(defun bb/evil-delete--black-hole-register (orig-fn beg end &optional type _ &rest args)
  (apply orig-fn beg end type ?_ args))

(advice-add 'evil-delete-char :around 'bb/evil-delete--black-hole-register)
(advice-add 'evil-delete-backward-char :around 'bb/evil-delete--black-hole-register)
#+end_src

#+RESULTS:

*** Fuzzi file finder
**** Main config
#+begin_src elisp
(after! counsel
  (advice-add 'counsel-fzf :around #'brust-counsel-fzf-advice-add-hide-files)

  (map!
   (:leader
     (:prefix "f"
       (:prefix ("z" . "Fuzzy find")
         :desc "Current dir" "z" #'counsel-fzf
         :desc "Drobox"      "d" #'brust-counsel-fzf-dropbox
         :desc "grep git"    "g" #'fzf-git-grep
         :desc "Home"        "h" #'brust-counsel-fzf-home
         :desc "Select dir"  "s" #'brust-counsel-fzf-dir
         :desc ".emacs.d"    "e" #'brust-counsel-fzf-emacsd)))))
#+end_src

#+RESULTS:
: brust-counsel-fzf-emacsd

**** Advice counsel-fzf to include hidden files
;; Install ag with:
;; sudo apt install silversearcher-ag
#+begin_src elisp
(defun brust-counsel-fzf-advice-add-hide-files (orig-fun &rest args)
  (if current-prefix-arg
      (let* ((ag-args (with-temp-buffer
                        (ivy-read "Arguments for ag: "
                                  '(("Hidden files but not .gitignoreds --hidden --ignore .git -g \"\"" . "--hidden --ignore .git -g \"\"")
                                    ("Hidden files and .gitignoreds -U --hidden --ignore .git -g \"\""  . "-U --hidden --ignore .git -g \"\""))
                                  :action (lambda (x) (insert (if (listp x) (cdr x) x))))
                        (buffer-string)))
             (counsel-fzf-cmd (concat "ag " ag-args " | fzf -f \"%s\"")))
        (apply orig-fun args))
    (apply orig-fun args)))

#+end_src

#+RESULTS:
: brust-counsel-fzf-advice-add-hide-files

**** Workaround for jumping to specific dirs
#+begin_src elisp
(defun brust-counsel-fzf-dir nil
  "fzf find file selecting a directory"
  (interactive)
  (let ((μdir (read-directory-name "Directory: ")))
    (counsel-fzf
     nil
     μdir
     (concat "fzf in " μdir ": "))))

(defun brust-counsel-fzf-home nil
  "fzf find file in home"
  (interactive)
  (counsel-fzf
   nil
   "~"
   "fzf in Home: "))

(defun brust-counsel-fzf-emacsd nil
  "fzf find file in .emacs.d"
  (interactive)
  (counsel-fzf
   nil
   "~/.emacs.d"
   "fzf in .emacs.d: "))

(defun brust-counsel-fzf-dropbox nil
  "fzf find file in Dropbox"
  (interactive)
  (counsel-fzf
   nil
   "~/Dropbox"
   "fzf in Dropbox: "))
#+end_src

#+RESULTS:
: brust-counsel-fzf-dropbox

*** Ivy
**** General ivy
    - Learn ivy-bibtex
#+BEGIN_SRC elisp
(after! ivy
  (setq ivy-use-virtual-buffers t
        +ivy-buffer-preview t
        counsel-find-file-at-point t
        ;; ivy-initial-inputs-alist nil ; remove initial ^ input.
        ;; ivy-virtual-abbreviate 'full ; properly use of bookmarks
        ;; ivy-height 10 ;; is already in module
        ivy-count-format "(%d/%d) "
        ivy-extra-directories nil ; remove . and .. directory.
        ;; Don't open in directory-mode
        ;; Always ignore buffers set in `ivy-ignore-buffers'
        ivy-use-ignore-default 'always)
  ;; Ignore some buffers in `ivy-switch-buffer'
  ;; (cl-loop for xx in
  ;;          '("company-statistics-cache.el"
  ;;            "^\\*vc\\*$"
  ;;            "^\\*log-edit-files\\*$"
  ;;            "^\\*Ibuffer\\*$"
  ;;            ;; "^\\*Org Src .*$"
  ;;            "^\\*magit[-a-z]*:.*$")
  ;;          do  (cl-pushnew xx ivy-ignore-buffers))
  ;; ;; Ignore some files in `counsel-find-file'
  ;; (setq counsel-find-file-ignore-regexp
  ;;       (concat "\\(^#.*#$\\)\\|\\(^.*~$\\)\\|\\(^\\..*$\\)"
  ;;               (cl-loop for -xx in
  ;;                        '(;; ".aux" ".bbl"
  ;;                          ".blg" ".exe"
  ;;                          ".log" ".meta" ".out" ;;".pdf"
  ;;                          ".synctex.gz" ".tdo" ".toc"
  ;;                          ".elc" ".eld" ".tex~" ".el~"
  ;;                          ".bcf" ".fls" ".rel" ".fdb_latexmk")
  ;;                        ;; may be add '("-pkg.el" "-autoloads.el")
  ;;                        do
  ;;                        (cl-pushnew
  ;;                         (concat "^.*\\" -xx "$")
  ;;                         ivy-ignore-buffers)
  ;;                        concat (concat "\\|\\(^.*\\" -xx "\\)") into file-regexp
  ;;                        finally return file-regexp)))

  (map!
   (:map ivy-minibuffer-map
    ;; Motion
    ;;         Now   I use LOWER form my keyboard
    ;;         "M-j" #'ivy-next-line
    ;;         "M-k" #'ivy-previous-line
    ;; Finish
    "<right>"  #'ivy-alt-done
    ";"   #'ivy-immediate-done
    ;; Interaction
    "M-w"      #'ivy-yank-word
    "M-o"      #'ivy-dispatching-done
    ;; "C-o"      #'hydra-ivy/body
    "C-<"      #'ivy-minibuffer-shrink
    "C->"      #'ivy-minibuffer-grow
    "M-j"      #'ivy-next-history-element
    "M-k"      #'ivy-previous-history-element
    "M-m"      #'ivy-mark
    ;; Security
    "<return>" #'nil
    )))
#+END_SRC

#+RESULTS:
**** Rich
Enlarge width of some columns
#+begin_src elisp
(after! ivy
  (let* ((plist (plist-get ivy-rich-display-transformers-list 'ivy-switch-buffer))
         (switch-buffer-alist (assq 'ivy-switch-buffer-transformer (plist-get plist :columns))))
    (when switch-buffer-alist
      (setcdr switch-buffer-alist '((:width 80)))))

  (let* ((plist (plist-get ivy-rich-display-transformers-list 'counsel-M-x))
         (switch-buffer-alist (assq 'counsel-M-x-transformer (plist-get plist :columns))))
    (when switch-buffer-alist
      (setcdr switch-buffer-alist '((:width 50)))))
  )
#+end_src

#+RESULTS:
| :width | 50 |

*** Key-frequency
#+BEGIN_SRC elisp
(use-package! keyfreq
  :init
  (keyfreq-mode 1)
  (keyfreq-autosave-mode 1)
  (setq keyfreq-excluded-commands
        '(self-insert-command
          forward-char
          backward-char
          previous-line
          next-line)))
#+END_SRC

#+RESULTS:
: keyfreq

*** Magit
    For a git and github integration with emacs!
#+BEGIN_SRC elisp
(after! magit
  (setq magit-turn-on-auto-revert-mode nil
        magit-diff-hide-trailing-cr-characters t
        magit-set-upstream-on-push 'dontask
        magit-completing-read-function 'ivy-completing-read
        magit-display-buffer-function 'magit-display-buffer-fullframe-status-v1
        magit-save-repository-buffers 'dontask
        magit-diff-paint-whitespace t
        magit-diff-refine-ignore-whitespace nil
        magit-diff-refine-hunk t)

  (add-hook 'magit-log-edit-mode-hook #'turn-on-flyspell)
  (add-hook 'git-commit-mode-hook #'turn-on-flyspell))
#+END_SRC

#+RESULTS:
: magit-status
*** Nyan
    Show the rainbow progres line.
#+BEGIN_SRC elisp
(use-package! nyan-mode
  :defer t
  :init
  (add-hook! 'emacs-startup-hook (nyan-mode +1))
  :config
  (setq nyan-minimum-window-width 90
        ;;nyan-cat-face-number 3
        +nyan-outerspace-image+ "~/.doom.d/local/outerspace.xpm"
        nyan-wavy-trail nil
        nyan-animate-nyancat nil
        ;; nyan-animation-frame-interval 0.2
        nyan-bar-length 36)
  ;; (nyan-start-animation)
  )

(use-package! zone
  :after nyan-mode
  :config
  (zone-when-idle (* 5 60)))

(use-package! zone-nyan
  :after zone
  :config
  (setq zone-programs [zone-nyan]
        zone-nyan-hide-progress t))
#+END_SRC

*** Pdf tools
#+BEGIN_SRC elisp
(after! pdf-tools
  ;; open pdfs scaled to fit page
  ;; (setq-default pdf-view-display-size 'fit-page)
  ;; automatically annotate highlights
  (setq pdf-annot-activate-created-annotations t
        pdf-view-resize-factor 1.1)
  ;; faster motion
  (map!
   :map pdf-view-mode-map
   :n "<"            #'pdf-view-first-page
   :n ">"            #'pdf-view-last-page
   :n "q"            #'kill-current-buffer
   ;; "C-k"          #'pdf-view-next-page-command
   ;; "C-i"          #'pdf-view-previous-page-command
   ;; "s-SPC"        #'pdf-view-scroll-down-or-previous-page
   :n "s-j"          #'pdf-view-next-line-or-next-page
   :n "s-k"          #'pdf-view-previous-line-or-previous-page
   :n "s-h"          #'image-backward-hscroll
   :n "s-l"          #'image-forward-hscroll
   :n "j"            #'brust-pdf-view-next-line-or-next-page-5
   :n "k"            #'brust-pdf-view-previous-line-or-previous-page-5
   :n "h"            #'brust-image-backward-hsroll-5
   :n "l"            #'brust-image-forward-hsroll-5
   ;; "C-n"          #'brust-ace-window
   ;; "n"            #'brust-ace-window
   :n "<mouse-5>"    #'brust-pdf-view-next-line-or-next-page-5
   :n "<mouse-4>"    #'brust-pdf-view-previous-line-or-previous-page-5
   :n "C-<mouse-5>"  #'pdf-view-next-page-command
   :n "C-<mouse-4>"  #'pdf-view-previous-page-command
   :n "s-<mouse-5>"  #'pdf-view-next-line-or-next-page
   :n "s-<mouse-4>"  #'pdf-view-previous-line-or-previous-page
   ;; :n "."            #'hydra-pdftools/body
   ))

;; (eval-after-load 'interleave
;; (add-hook 'pdf-view-mode-hook #'brust-pdf-tools-hook t))

(defun brust-image-backward-hsroll-5 (args)
  (interactive "p")
  (brust-by-five #'image-backward-hscroll args))
(defun brust-image-forward-hsroll-5 (args)
  (interactive "p")
  (brust-by-five #'image-forward-hscroll args))
(defun brust-pdf-view-next-line-or-next-page-5 (args)
  (interactive "p")
  (brust-by-five #'pdf-view-next-line-or-next-page args))
(defun brust-pdf-view-previous-line-or-previous-page-5 (args)
  (interactive "p")
  (brust-by-five #'pdf-view-previous-line-or-previous-page args))
#+END_SRC

#+RESULTS:
: brust-pdf-view-previous-line-or-previous-page-5
*** Prettify symbols
[[https://www.reddit.com/r/emacs/comments/ctfxbg/emacs_doom_e15_fancy_task_priorities_in_org_mode/][reddit prettify org-mode]]
**** Load utils
#+begin_src elisp
;; (load "~/.doom.d/local/lisp/prettify-utils/prettify-utils.el" t nil t)
;; (add-load-path! "~/.doom.d/local/lisp/prettify-utils/")
(cl-pushnew  "~/.doom.d/local/lisp/prettify-utils/" load-path :test #'string=)
(autoload 'prettify-utils-add-hook "prettify-utils"
  "Add hook to mode defining pretty symbols alist" t)
#+end_src
**** eLisp
#+begin_src elisp
(defconst lisp--prettify-symbols-alist
  '(("lambda"  . ?λ)))
#+end_src
**** Org-mode
#+begin_src elisp
(add-hook! 'emacs-startup-hook
  (prettify-utils-add-hook org-mode
                           ("[ ]"       "☐")
                           ("[X]"       "☑")
                           ("[-]"       "❍")))

;; ("TODO"      "⚑")
;; ("DOING"     "⚐")
;; ("CANCELED"  "✘")
;; ("DONE"      "✔"))
;; It does not use regexp... wtf!!
;; ("^\\(\\*\\{1\\}\\) " "☰")
;; ("^\\(\\*\\{2\\}\\) " "☱")
;; ("^\\(\\*\\{3\\}\\) " "☲")
;; ("^\\(\\*\\{4\\}\\) " "☳")
;; ("^\\(\\*\\{5\\}\\) " "☴")
;; ("^\\(\\*\\{6\\}\\) " "☵")
;; ("^\\(\\*\\{7\\}\\) " "☶")
;; ("^\\(\\*\\{8\\}\\) " "☷"))
#+end_src

*** Surround
#+begin_src elisp
(setq-default
 evil-surround-pairs-alist
 '((?\( . ("(" . ")"))
   (?\[ . ("[" . "]"))
   (?\{ . ("{" . "}"))
   (?< . ("<" . ">"))

   (?\) . ("\\(" . "\\)"))
   (?\] . ("\\[\n" . "\n\\]"))
   ;; (?\) . ("(" . ")"))
   ;; (?\] . ("[" . "]"))
   ;; (?\} . ("{" . "}"))

   ;; (?# . ("#{" . "}"))
   ;; (?b . ("(" . ")"))
   ;; (?B . ("{" . "}"))
   (?t . evil-surround-read-tag)
   (?> . evil-surround-read-tag)
   (?f . evil-surround-function)))

;; this macro was copied from here: https://stackoverflow.com/a/22418983/4921402
(defmacro define-and-bind-quoted-text-object (name key start-regex end-regex)
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-a-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regex ,end-regex beg end type count t))
       (define-key evil-inner-text-objects-map ,key #',inner-name)
       (define-key evil-outer-text-objects-map ,key #',outer-name))))

(define-and-bind-quoted-text-object "dollar" "r" "\\$" "\\$") ;; sometimes your have to escape the regex
(define-and-bind-quoted-text-object "ddollar" "$" "\\$\\$" "\\$\\$") ;; sometimes your have to escape the regex
(define-and-bind-quoted-text-object "inmath" ")" "\\\\(" "\\\\)")
(define-and-bind-quoted-text-object "dismath" "]" "\\\\[" "\\\\]")

(defun brust-embrace-LaTeX-mode-hook ()
  (dolist (lst '((?= "\\verb|" . "|")
                 (?~ "\\texttt{" . "}")
                 (?/ "\\emph{" . "}")
                 (?* "\\textbf{" . "}")))
    (embrace-add-pair (car lst) (cadr lst) (cddr lst))))
#+end_src

#+RESULTS:
: brust-embrace-LaTeX-mode-hook

*** Turn grep "writable" buffer
#+BEGIN_SRC elisp
(use-package! wgrep
  :defer t
  :config
  (setq wgrep-auto-save-buffer t
        wgrep-enable-key "r"))
#+END_SRC

*** Visual regexp
#+BEGIN_SRC elisp
(use-package! visual-regexp
  :commands (vr/replace vr/query-replace))
#+END_SRC

*** Yassnippets
**** jasnippets
#+begin_src elisp
;; for functions
(defun julia-split-args (arg-string)
  "Split a julia argument string into ((name, default)..) tuples"
  (mapcar (lambda (x)
             (split-string x "[[:blank:]]*=[[:blank:]]*" t))
          (split-string arg-string "[[:blank:]]*[,;][[:blank:]]*" t)))

(defun julia-args-to-docstring ()
  "return docstring format for the julia arguments in yas-text"
  (let* ((indent (concat "\n" (make-string (current-column) 32)))
         (args (julia-split-args yas-text))
         (max-len (if args (apply 'max (mapcar (lambda (x) (length (nth 0 x))) args)) 0))
         (formatted-args (mapconcat
                (lambda (x)
                   (concat "- " (nth 0 x) (make-string (- max-len (length (nth 0 x))) ? ) " : "
                           (if (nth 1 x) (concat "\(default " (nth 1 x) "\)"))))
                args
                indent)))
    (unless (string= formatted-args "")
      (mapconcat 'identity (list "# Arguments" formatted-args) indent))))

#+end_src

*** Zoom
#+begin_src elisp
(use-package! zoom
  :defer t
  :init
  (setq zoom-size '(0.618 . 0.618)
        zoom-ignored-major-modes '("dired-mode"
                                   "ediff-mode"
                                   ;; "eshell-mode"
                                   ;; "neotree-mode"
                                   "sr-speedbar-mode")
        zoom-ignored-buffer-name-regexps '("^*calc" "^\\*magit: +.*"))
  (add-hook! 'emacs-startup-hook (zoom-mode +1)))

(after! ediff
  (add-hook! 'ediff-before-setup-hook (zoom-mode -1))
  (add-hook! 'ediff-cleanup-hook (zoom-mode +1))
  )
#+end_src

#+RESULTS:
| brust-zoom-on |

